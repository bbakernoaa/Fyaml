var tipuesearch = {"pages":[{"title":" Fyaml ","text":"Fyaml Fyaml - A Modern Fortran YAML Parser A lightweight YAML parser written in modern Fortran that supports nested structures, sequences, and various data types. Designed for scientific computing applications needing configuration file support. Features Parse YAML files into native Fortran data structures Support for strings, integers, floats, booleans, and null values Handle nested mappings and sequences Comment parsing Debug logging with configurable levels Dot notation access for nested values Memory safe with pointer management Requirements Fortran 2008 compliant compiler (gfortran 8.0+ or ifort 19.0+) CMake 3.12+ Installation git clone https://github.com/yourusername/fyaml.git cd fyaml\nmkdir build && cd build\ncmake ..\nmake\nmake install Usage 1) Create a YAML configuration file: database : host : localhost port : 5432 credentials : username : admin password : secret 2) Parse it in your Fortran code: program example use fyaml type ( fyaml_doc ) :: doc type ( yaml_value ) :: val call doc % load ( \"config.yaml\" ) val = doc % root % get ( \"database.host\" ) print * , \"Host:\" , val % str_val end program Project Structure . ├── CMakeLists . txt ├── src / │ ├── yaml_types . f90 ! Core type definitions │ ├── yaml_parser . f90 ! YAML parsing implementation │ └── fyaml . f90 ! High - level interface ├── tests / │ └── test_example . yaml └── example / ├── example . yaml └── yaml_example . f90 Testing cd build\nctest --output-on-failure Documentation Documentation is generated using FORD. To build: ford .ford License GNU General Public License v3.0 Contributing Contributions welcome! Please read CONTRIBUTING.md for guidelines. Developer Info Barry Baker","tags":"home","loc":"index.html"},{"title":"yaml_document – Fyaml ","text":"type, public :: yaml_document Document type containing full YAML structure Root container for a YAML document tree. Holds reference to\ntop-level node and document-wide settings. Inherits type~~yaml_document~~InheritsGraph type~yaml_document yaml_document type~yaml_node yaml_node type~yaml_document->type~yaml_node root type~yaml_node->type~yaml_node children, next Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~yaml_document~~InheritedByGraph type~yaml_document yaml_document type~yaml_wrapper yaml_wrapper type~yaml_wrapper->type~yaml_document raw_doc Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( yaml_node ), public, pointer :: root => null()","tags":"","loc":"type/yaml_document.html"},{"title":"yaml_error – Fyaml ","text":"type, public :: yaml_error Error handling type for YAML operations Used to track and report errors during YAML processing. Components Type Visibility Attributes Name Initial logical, public :: has_error = .false. character(len=256), public :: message = ''","tags":"","loc":"type/yaml_error.html"},{"title":"yaml_node – Fyaml ","text":"type, public :: yaml_node Node type representing a single YAML element Core type for building YAML document trees. Can represent scalars,\nsequences, and mappings with type information and linking. Inherited by type~~yaml_node~~InheritedByGraph type~yaml_node yaml_node type~yaml_node->type~yaml_node children, next type~yaml_document yaml_document type~yaml_document->type~yaml_node root type~yaml_wrapper yaml_wrapper type~yaml_wrapper->type~yaml_document raw_doc Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( yaml_node ), public, pointer :: children => null() logical, public :: is_boolean = .false. logical, public :: is_float = .false. logical, public :: is_integer = .false. logical, public :: is_null = .false. logical, public :: is_sequence = .false. logical, public :: is_string = .true. character(len=:), public, allocatable :: key type( yaml_node ), public, pointer :: next => null() character(len=:), public, allocatable :: value","tags":"","loc":"type/yaml_node.html"},{"title":"fyaml_doc – Fyaml ","text":"type, public :: fyaml_doc YAML document container Inherits type~~fyaml_doc~~InheritsGraph type~fyaml_doc fyaml_doc type~yaml_dict yaml_dict type~fyaml_doc->type~yaml_dict root type~yaml_pair yaml_pair type~yaml_dict->type~yaml_pair first type~yaml_pair->type~yaml_dict nested type~yaml_pair->type~yaml_pair next type~yaml_value yaml_value type~yaml_pair->type~yaml_value value type~yaml_value->type~yaml_dict dict_val Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~fyaml_doc~~InheritedByGraph type~fyaml_doc fyaml_doc type~yaml_wrapper yaml_wrapper type~yaml_wrapper->type~fyaml_doc doc Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( yaml_dict ), public :: root Type-Bound Procedures procedure, public :: load => load_yaml_doc private  subroutine load_yaml_doc(this, filename, success) Load YAML document from file @param[in,out] this     The document instance\n@param[in]     filename Path to YAML file\n@param[out]    success  Optional success indicator Arguments Type Intent Optional Attributes Name class( fyaml_doc ), intent(inout) :: this character(len=*), intent(in) :: filename logical, intent(out), optional :: success","tags":"","loc":"type/fyaml_doc.html"},{"title":"yaml_dict – Fyaml ","text":"type, public :: yaml_dict Dictionary container type Inherits type~~yaml_dict~~InheritsGraph type~yaml_dict yaml_dict type~yaml_pair yaml_pair type~yaml_dict->type~yaml_pair first type~yaml_pair->type~yaml_dict nested type~yaml_pair->type~yaml_pair next type~yaml_value yaml_value type~yaml_pair->type~yaml_value value type~yaml_value->type~yaml_dict dict_val Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~yaml_dict~~InheritedByGraph type~yaml_dict yaml_dict type~yaml_pair yaml_pair type~yaml_dict->type~yaml_pair first type~fyaml_doc fyaml_doc type~fyaml_doc->type~yaml_dict root type~yaml_pair->type~yaml_dict nested type~yaml_pair->type~yaml_pair next type~yaml_value yaml_value type~yaml_pair->type~yaml_value value type~yaml_value->type~yaml_dict dict_val type~yaml_wrapper yaml_wrapper type~yaml_wrapper->type~yaml_dict dict type~yaml_wrapper->type~fyaml_doc doc Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: count = 0 type( yaml_pair ), public, pointer :: first => null() Type-Bound Procedures procedure, public :: get => get_value private  function get_value(this, key) result(val) Get value associated with key from dictionary @param[in]  this Dictionary instance\n@param[in]  key  Key to lookup\n@return     Value associated with key Arguments Type Intent Optional Attributes Name class( yaml_dict ), intent(in) :: this character(len=*), intent(in) :: key Return Value type( yaml_value ) procedure, public :: keys => get_keys private  function get_keys(this) result(keys) Get all keys in dictionary @param[in]  this Dictionary instance\n@return     Array of all keys Arguments Type Intent Optional Attributes Name class( yaml_dict ), intent(in) :: this Return Value character(len=:), allocatable, dimension(:) procedure, public :: set => set_value private  subroutine set_value(this, key, value) Set value for a given key in dictionary @param[in,out] this  The dictionary instance\n@param[in]     key   Key to set\n@param[in]     value Value to associate with key Arguments Type Intent Optional Attributes Name class( yaml_dict ), intent(inout) :: this character(len=*), intent(in) :: key type( yaml_value ), intent(in) :: value","tags":"","loc":"type/yaml_dict.html"},{"title":"yaml_pair – Fyaml ","text":"type, public :: yaml_pair Dictionary key-value pair type Inherits type~~yaml_pair~~InheritsGraph type~yaml_pair yaml_pair type~yaml_pair->type~yaml_pair next type~yaml_dict yaml_dict type~yaml_pair->type~yaml_dict nested type~yaml_value yaml_value type~yaml_pair->type~yaml_value value type~yaml_dict->type~yaml_pair first type~yaml_value->type~yaml_dict dict_val Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~yaml_pair~~InheritedByGraph type~yaml_pair yaml_pair type~yaml_pair->type~yaml_pair next type~yaml_dict yaml_dict type~yaml_pair->type~yaml_dict nested type~yaml_value yaml_value type~yaml_pair->type~yaml_value value type~yaml_dict->type~yaml_pair first type~fyaml_doc fyaml_doc type~fyaml_doc->type~yaml_dict root type~yaml_value->type~yaml_dict dict_val type~yaml_wrapper yaml_wrapper type~yaml_wrapper->type~yaml_dict dict type~yaml_wrapper->type~fyaml_doc doc Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: key type( yaml_dict ), public, pointer :: nested => null() type( yaml_pair ), public, pointer :: next => null() type( yaml_value ), public :: value","tags":"","loc":"type/yaml_pair.html"},{"title":"yaml_value – Fyaml ","text":"type, public :: yaml_value Value container type supporting multiple YAML data types Inherits type~~yaml_value~~InheritsGraph type~yaml_value yaml_value type~yaml_dict yaml_dict type~yaml_value->type~yaml_dict dict_val type~yaml_pair yaml_pair type~yaml_dict->type~yaml_pair first type~yaml_pair->type~yaml_value value type~yaml_pair->type~yaml_dict nested type~yaml_pair->type~yaml_pair next Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~yaml_value~~InheritedByGraph type~yaml_value yaml_value type~yaml_dict yaml_dict type~yaml_value->type~yaml_dict dict_val type~yaml_pair yaml_pair type~yaml_pair->type~yaml_value value type~yaml_pair->type~yaml_pair next type~yaml_pair->type~yaml_dict nested type~yaml_dict->type~yaml_pair first type~fyaml_doc fyaml_doc type~fyaml_doc->type~yaml_dict root type~yaml_wrapper yaml_wrapper type~yaml_wrapper->type~yaml_dict dict type~yaml_wrapper->type~fyaml_doc doc Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical, public :: bool_val type( yaml_dict ), public, pointer :: dict_val => null() integer, public :: int_val logical, public :: is_null = .false. real, public :: real_val character(len=:), public, allocatable, dimension(:) :: sequence character(len=:), public, allocatable :: str_val integer, public :: value_type = 0 Type-Bound Procedures procedure, public :: get => get_nested_value private recursive function get_nested_value(self, key) result(val) Get nested value using dot notation path @param[in]  self YAML value instance\n@param[in]  key  Dot-separated path (e.g. \"database.host\")\n@return     Value at specified path Arguments Type Intent Optional Attributes Name class( yaml_value ), intent(in) :: self character(len=*), intent(in) :: key Return Value type( yaml_value )","tags":"","loc":"type/yaml_value.html"},{"title":"yaml_wrapper – Fyaml ","text":"type, public :: yaml_wrapper YAML document wrapper with raw and processed forms Inherits type~~yaml_wrapper~~InheritsGraph type~yaml_wrapper yaml_wrapper type~fyaml_doc fyaml_doc type~yaml_wrapper->type~fyaml_doc doc type~yaml_dict yaml_dict type~yaml_wrapper->type~yaml_dict dict type~yaml_document yaml_document type~yaml_wrapper->type~yaml_document raw_doc type~fyaml_doc->type~yaml_dict root type~yaml_pair yaml_pair type~yaml_dict->type~yaml_pair first type~yaml_node yaml_node type~yaml_document->type~yaml_node root type~yaml_node->type~yaml_node children, next type~yaml_pair->type~yaml_dict nested type~yaml_pair->type~yaml_pair next type~yaml_value yaml_value type~yaml_pair->type~yaml_value value type~yaml_value->type~yaml_dict dict_val Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( yaml_dict ), public :: dict type( fyaml_doc ), public :: doc type( yaml_document ), public :: raw_doc Type-Bound Procedures procedure, public :: convert => convert_to_dict private  subroutine convert_to_dict(this) Convert raw YAML document to dictionary structure @param[in,out] this Wrapper instance containing raw and processed forms Arguments Type Intent Optional Attributes Name class( yaml_wrapper ), intent(inout) :: this procedure, public :: load => load_yaml_wrapper private  subroutine load_yaml_wrapper(this, filename) Load and process YAML document through wrapper @param[in,out] this     The wrapper instance\n@param[in]     filename Path to YAML file Arguments Type Intent Optional Attributes Name class( yaml_wrapper ), intent(inout) :: this character(len=*), intent(in) :: filename","tags":"","loc":"type/yaml_wrapper.html"},{"title":"count_leading_spaces – Fyaml","text":"public  function count_leading_spaces(line) Count leading spaces in a string Used for determining indentation level @param[in]  line Input string\n@return     Number of leading spaces Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer Called by proc~~count_leading_spaces~~CalledByGraph proc~count_leading_spaces count_leading_spaces proc~parse_line parse_line proc~parse_line->proc~count_leading_spaces proc~parse_yaml parse_yaml proc~parse_yaml->proc~parse_line Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/count_leading_spaces.html"},{"title":"is_int_string – Fyaml","text":"public  function is_int_string(str) result(is_int) Check if string represents an integer @param[in] str String to check\n@return True if string can be parsed as integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value logical Called by proc~~is_int_string~~CalledByGraph proc~is_int_string is_int_string proc~determine_value_type determine_value_type proc~determine_value_type->proc~is_int_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: i_value integer, public :: iostat","tags":"","loc":"proc/is_int_string.html"},{"title":"is_real_string – Fyaml","text":"public  function is_real_string(str) result(is_real) Check if string can be parsed as real number @param[in]  str String to check\n@return     True if string represents a real number Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value logical Called by proc~~is_real_string~~CalledByGraph proc~is_real_string is_real_string proc~determine_value_type determine_value_type proc~determine_value_type->proc~is_real_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: iostat real, public :: r_value","tags":"","loc":"proc/is_real_string.html"},{"title":"to_lower – Fyaml","text":"public  function to_lower(str) result(lower_str) Convert string to lowercase @param[in]  str Input string\n@return     Lowercase version of input Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len) Called by proc~~to_lower~~CalledByGraph proc~to_lower to_lower proc~determine_value_type determine_value_type proc~determine_value_type->proc~to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/to_lower.html"},{"title":"debug_print – Fyaml","text":"public  subroutine debug_print(level, message, error_code) Debug message printer Prints debug messages based on current debug level @param[in] level Debug level of message\n@param[in] message Debug message to print\n@param[in] error_code Optional error code to include Arguments Type Intent Optional Attributes Name integer, intent(in) :: level character(len=*), intent(in) :: message integer, intent(in), optional :: error_code Called by proc~~debug_print~~CalledByGraph proc~debug_print debug_print proc~parse_line parse_line proc~parse_line->proc~debug_print proc~parse_yaml parse_yaml proc~parse_yaml->proc~debug_print proc~parse_yaml->proc~parse_line proc~validate_node validate_node proc~validate_node->proc~debug_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/debug_print.html"},{"title":"determine_value_type – Fyaml","text":"public  subroutine determine_value_type(node) Determine value type of node Checks content and sets appropriate type flags @param[in,out] node Node to analyze Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(inout) :: node Calls proc~~determine_value_type~~CallsGraph proc~determine_value_type determine_value_type proc~is_int_string is_int_string proc~determine_value_type->proc~is_int_string proc~is_real_string is_real_string proc~determine_value_type->proc~is_real_string proc~to_lower to_lower proc~determine_value_type->proc~to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: i_value logical, public :: is_int logical, public :: is_real logical, public :: l_value real, public :: r_value integer, public :: rc character(len=32), public :: temp_str","tags":"","loc":"proc/determine_value_type.html"},{"title":"initialize_document – Fyaml","text":"public  subroutine initialize_document(doc) Initialize a new YAML document Sets up empty document structure with nullified root @param[in,out] doc Document to initialize Arguments Type Intent Optional Attributes Name type( yaml_document ), intent(inout) :: doc Called by proc~~initialize_document~~CalledByGraph proc~initialize_document initialize_document proc~parse_yaml parse_yaml proc~parse_yaml->proc~initialize_document Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/initialize_document.html"},{"title":"initialize_node – Fyaml","text":"public  subroutine initialize_node(node) Initialize a new YAML node Sets default values for a newly created node @param[in,out] node Node to initialize Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(inout), pointer :: node Called by proc~~initialize_node~~CalledByGraph proc~initialize_node initialize_node proc~parse_line parse_line proc~parse_line->proc~initialize_node proc~parse_mapping parse_mapping proc~parse_mapping->proc~initialize_node proc~parse_sequence parse_sequence proc~parse_sequence->proc~initialize_node proc~parse_flow_form parse_flow_form proc~parse_flow_form->proc~parse_mapping proc~parse_flow_form->proc~parse_sequence proc~parse_yaml parse_yaml proc~parse_yaml->proc~parse_line Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/initialize_node.html"},{"title":"parse_flow_form – Fyaml","text":"public  subroutine parse_flow_form(line, node) Parse flow-style YAML syntax Handles flow-style sequences [...] and mappings {...} @param[in]     line Input containing flow syntax\n@param[in,out] node Node to store parsed content Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line type( yaml_node ), intent(inout), pointer :: node Calls proc~~parse_flow_form~~CallsGraph proc~parse_flow_form parse_flow_form proc~parse_mapping parse_mapping proc~parse_flow_form->proc~parse_mapping proc~parse_sequence parse_sequence proc~parse_flow_form->proc~parse_sequence proc~initialize_node initialize_node proc~parse_mapping->proc~initialize_node proc~parse_sequence->proc~initialize_node Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: content integer, public :: end integer, public :: pos integer, public :: start","tags":"","loc":"proc/parse_flow_form.html"},{"title":"parse_line – Fyaml","text":"public  subroutine parse_line(line, doc, status) Parse a single line of YAML content Processes a line and updates document structure. Handles:\n- Indentation\n- Sequence items\n- Key-value pairs\n- Nested structures @param[in]     line Input line\n@param[in,out] doc  Document being built\n@param[out]    status Status code Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line type( yaml_document ), intent(inout) :: doc integer, intent(out) :: status Calls proc~~parse_line~~CallsGraph proc~parse_line parse_line proc~count_leading_spaces count_leading_spaces proc~parse_line->proc~count_leading_spaces proc~debug_print debug_print proc~parse_line->proc~debug_print proc~initialize_node initialize_node proc~parse_line->proc~initialize_node Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_line~~CalledByGraph proc~parse_line parse_line proc~parse_yaml parse_yaml proc~parse_yaml->proc~parse_line Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: current_indent type( yaml_node ), public, pointer :: current_node character(len=256), public :: debug_msg integer, public :: io_stat logical, public :: is_sequence_item character(len=:), public, allocatable :: local_line type( yaml_node ), public, pointer :: new_node integer, public :: parent_indent type( yaml_node ), public, pointer :: parent_node integer, public :: pos","tags":"","loc":"proc/parse_line.html"},{"title":"parse_mapping – Fyaml","text":"public  subroutine parse_mapping(content, node) Parse mapping elements from flow style Splits comma-separated key-value pairs into nodes @param[in,out] content Mapping content string\n@param[in,out] node Node to store mapping Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: content type( yaml_node ), intent(inout), pointer :: node Calls proc~~parse_mapping~~CallsGraph proc~parse_mapping parse_mapping proc~initialize_node initialize_node proc~parse_mapping->proc~initialize_node Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_mapping~~CalledByGraph proc~parse_mapping parse_mapping proc~parse_flow_form parse_flow_form proc~parse_flow_form->proc~parse_mapping Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: content_len character(len=:), public, allocatable :: key character(len=:), public, allocatable :: local_content character(len=:), public, allocatable :: pair integer, public :: pos character(len=:), public, allocatable :: value","tags":"","loc":"proc/parse_mapping.html"},{"title":"parse_sequence – Fyaml","text":"public  subroutine parse_sequence(content, node) Parse sequence elements from flow style Splits comma-separated sequence items into nodes @param[in,out] content Sequence content string\n@param[in,out] node Node to store sequence Arguments Type Intent Optional Attributes Name character(len=:), intent(inout), allocatable :: content type( yaml_node ), intent(inout), pointer :: node Calls proc~~parse_sequence~~CallsGraph proc~parse_sequence parse_sequence proc~initialize_node initialize_node proc~parse_sequence->proc~initialize_node Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_sequence~~CalledByGraph proc~parse_sequence parse_sequence proc~parse_flow_form parse_flow_form proc~parse_flow_form->proc~parse_sequence Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: item character(len=:), public, allocatable :: local_content integer, public :: pos","tags":"","loc":"proc/parse_sequence.html"},{"title":"parse_yaml – Fyaml","text":"public  subroutine parse_yaml(filename, docs, status) Parse a YAML file into document structure Reads and parses a YAML file into one or more documents @param[in]  filename Path to YAML file\n@param[out] docs     Array of parsed YAML documents\n@param[out] status   Status code (ERR_SUCCESS on success) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( yaml_document ), intent(out), allocatable :: docs (:) integer, intent(out) :: status Calls proc~~parse_yaml~~CallsGraph proc~parse_yaml parse_yaml proc~debug_print debug_print proc~parse_yaml->proc~debug_print proc~initialize_document initialize_document proc~parse_yaml->proc~initialize_document proc~parse_line parse_line proc~parse_yaml->proc~parse_line proc~parse_line->proc~debug_print proc~count_leading_spaces count_leading_spaces proc~parse_line->proc~count_leading_spaces proc~initialize_node initialize_node proc~parse_line->proc~initialize_node Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: doc_count logical, public :: doc_started character(len=256), public :: error_msg integer, public :: i logical, public :: in_document integer, public :: io_stat character(len=1024), public :: line integer, public :: line_count integer, public :: unit","tags":"","loc":"proc/parse_yaml.html"},{"title":"set_debug_level – Fyaml","text":"public  subroutine set_debug_level(level) Set the debug output level Controls how much debug information is printed during parsing @param[in] level Debug level (DEBUG_NONE through DEBUG_VERBOSE) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level","tags":"","loc":"proc/set_debug_level.html"},{"title":"validate_node – Fyaml","text":"public  subroutine validate_node(node, status) Validate node structure and contents Performs validation checks on node pointers and content @param[in] node Node to validate\n@param[out] status Status code (ERR_SUCCESS if valid) Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(in), pointer :: node integer, intent(out) :: status Calls proc~~validate_node~~CallsGraph proc~validate_node validate_node proc~debug_print debug_print proc~validate_node->proc~debug_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/validate_node.html"},{"title":"yaml_types – Fyaml","text":"YAML data type definitions module Provides derived type definitions for YAML parsing and representation.\nIncludes node types for building document trees and error handling. @author Barry Baker\n@version 0.1.0 Used by module~~yaml_types~~UsedByGraph module~yaml_types yaml_types module~fyaml fyaml module~fyaml->module~yaml_types module~yaml_parser yaml_parser module~fyaml->module~yaml_parser module~yaml_parser->module~yaml_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: yaml_document Document type containing full YAML structure Read more… Components Type Visibility Attributes Name Initial type( yaml_node ), public, pointer :: root => null() type, public :: yaml_error Error handling type for YAML operations Read more… Components Type Visibility Attributes Name Initial logical, public :: has_error = .false. character(len=256), public :: message = '' type, public :: yaml_node Node type representing a single YAML element Read more… Components Type Visibility Attributes Name Initial type( yaml_node ), public, pointer :: children => null() logical, public :: is_boolean = .false. logical, public :: is_float = .false. logical, public :: is_integer = .false. logical, public :: is_null = .false. logical, public :: is_sequence = .false. logical, public :: is_string = .true. character(len=:), public, allocatable :: key type( yaml_node ), public, pointer :: next => null() character(len=:), public, allocatable :: value","tags":"","loc":"module/yaml_types.html"},{"title":"yaml_parser – Fyaml","text":"YAML Parser module This module provides functionality for parsing YAML files into Fortran data structures.\nIt handles document structure, value types, indentation, sequences, and mapping nodes. Note Supports basic YAML features including scalars, sequences, and mappings\n@author Barry Baker\n@version 0.1.0\n@see yaml_types\n@see fyaml Uses yaml_types iso_fortran_env module~~yaml_parser~~UsesGraph module~yaml_parser yaml_parser iso_fortran_env iso_fortran_env module~yaml_parser->iso_fortran_env module~yaml_types yaml_types module~yaml_parser->module~yaml_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~yaml_parser~~UsedByGraph module~yaml_parser yaml_parser module~fyaml fyaml module~fyaml->module~yaml_parser Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: DEBUG_ERROR = 1 Show only error messages integer, public, parameter :: DEBUG_INFO = 3 Show general info messages integer, public, parameter :: DEBUG_NONE = 0 Disable all debug output integer, public, parameter :: DEBUG_VERBOSE = 4 Show verbose debug output integer, public, parameter :: DEBUG_WARN = 2 Show warnings and errors integer, public, parameter :: ERR_FILE_NOT_FOUND = 1 YAML file not found or inaccessible integer, public, parameter :: ERR_MEMORY = 4 Memory allocation error integer, public, parameter :: ERR_PARSE_ERROR = 3 Error parsing YAML content integer, public, parameter :: ERR_READ_ERROR = 2 Error reading from file integer, public, parameter :: ERR_SUCCESS = 0 Operation completed successfully integer, public :: debug_level = DEBUG_ERROR Functions public  function count_leading_spaces (line) Count leading spaces in a string Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer public  function is_int_string (str) result(is_int) Check if string represents an integer Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value logical public  function is_real_string (str) result(is_real) Check if string can be parsed as real number Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value logical public  function to_lower (str) result(lower_str) Convert string to lowercase Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len) Subroutines public  subroutine debug_print (level, message, error_code) Debug message printer Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: level character(len=*), intent(in) :: message integer, intent(in), optional :: error_code public  subroutine determine_value_type (node) Determine value type of node Read more… Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(inout) :: node public  subroutine initialize_document (doc) Initialize a new YAML document Read more… Arguments Type Intent Optional Attributes Name type( yaml_document ), intent(inout) :: doc public  subroutine initialize_node (node) Initialize a new YAML node Read more… Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(inout), pointer :: node public  subroutine parse_flow_form (line, node) Parse flow-style YAML syntax Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line type( yaml_node ), intent(inout), pointer :: node public  subroutine parse_line (line, doc, status) Parse a single line of YAML content Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line type( yaml_document ), intent(inout) :: doc integer, intent(out) :: status public  subroutine parse_mapping (content, node) Parse mapping elements from flow style Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: content type( yaml_node ), intent(inout), pointer :: node public  subroutine parse_sequence (content, node) Parse sequence elements from flow style Read more… Arguments Type Intent Optional Attributes Name character(len=:), intent(inout), allocatable :: content type( yaml_node ), intent(inout), pointer :: node public  subroutine parse_yaml (filename, docs, status) Parse a YAML file into document structure Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( yaml_document ), intent(out), allocatable :: docs (:) integer, intent(out) :: status public  subroutine set_debug_level (level) Set the debug output level Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: level public  subroutine validate_node (node, status) Validate node structure and contents Read more… Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(in), pointer :: node integer, intent(out) :: status","tags":"","loc":"module/yaml_parser.html"},{"title":"fyaml – Fyaml","text":"A modern Fortran module for parsing YAML files This module provides functionality to read and parse YAML files into Fortran\ndata structures. It supports nested dictionaries, sequences, and various data types. Note Currently supports strings, integers, reals, booleans, nulls, sequences and nested structures\n@author Barry Baker\n@date 2024\n@version 0.1.0\n@copyright GNU GENERAL PUBLIC LICENSE v3.0 Uses yaml_types yaml_parser iso_fortran_env module~~fyaml~~UsesGraph module~fyaml fyaml iso_fortran_env iso_fortran_env module~fyaml->iso_fortran_env module~yaml_parser yaml_parser module~fyaml->module~yaml_parser module~yaml_types yaml_types module~fyaml->module~yaml_types module~yaml_parser->iso_fortran_env module~yaml_parser->module~yaml_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: fyaml_doc YAML document container Components Type Visibility Attributes Name Initial type( yaml_dict ), public :: root Type-Bound Procedures procedure, public :: load => load_yaml_doc type, public :: yaml_dict Dictionary container type Components Type Visibility Attributes Name Initial integer, public :: count = 0 type( yaml_pair ), public, pointer :: first => null() Type-Bound Procedures procedure, public :: get => get_value procedure, public :: keys => get_keys procedure, public :: set => set_value type, public :: yaml_pair Dictionary key-value pair type Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: key type( yaml_dict ), public, pointer :: nested => null() type( yaml_pair ), public, pointer :: next => null() type( yaml_value ), public :: value type, public :: yaml_value Value container type supporting multiple YAML data types Components Type Visibility Attributes Name Initial logical, public :: bool_val type( yaml_dict ), public, pointer :: dict_val => null() integer, public :: int_val logical, public :: is_null = .false. real, public :: real_val character(len=:), public, allocatable, dimension(:) :: sequence character(len=:), public, allocatable :: str_val integer, public :: value_type = 0 Type-Bound Procedures procedure, public :: get => get_nested_value type, public :: yaml_wrapper YAML document wrapper with raw and processed forms Components Type Visibility Attributes Name Initial type( yaml_dict ), public :: dict type( fyaml_doc ), public :: doc type( yaml_document ), public :: raw_doc Type-Bound Procedures procedure, public :: convert => convert_to_dict procedure, public :: load => load_yaml_wrapper","tags":"","loc":"module/fyaml.html"},{"title":"yaml_types.F90 – Fyaml","text":"Files dependent on this one sourcefile~~yaml_types.f90~~AfferentGraph sourcefile~yaml_types.f90 yaml_types.F90 sourcefile~fyaml.f90 fyaml.F90 sourcefile~fyaml.f90->sourcefile~yaml_types.f90 sourcefile~yaml_parser.f90 yaml_parser.F90 sourcefile~fyaml.f90->sourcefile~yaml_parser.f90 sourcefile~yaml_parser.f90->sourcefile~yaml_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> YAML data type definitions module !! !! Provides derived type definitions for YAML parsing and representation. !! Includes node types for building document trees and error handling. !! !! @author Barry Baker !! @version 0.1.0 module yaml_types implicit none !> Node type representing a single YAML element !! !! Core type for building YAML document trees. Can represent scalars, !! sequences, and mappings with type information and linking. type :: yaml_node character ( len = :), allocatable :: key !< Node key name character ( len = :), allocatable :: value !< Node value content type ( yaml_node ), pointer :: children => null () !< Child nodes for nested structures type ( yaml_node ), pointer :: next => null () !< Next sibling node in sequence logical :: is_sequence = . false . !< True if node is part of sequence logical :: is_null = . false . !< True if node represents null value logical :: is_boolean = . false . !< True if node contains boolean value logical :: is_integer = . false . !< True if node contains integer value logical :: is_float = . false . !< True if node contains float value logical :: is_string = . true . !< True if node contains string value end type yaml_node !> Document type containing full YAML structure !! !! Root container for a YAML document tree. Holds reference to !! top-level node and document-wide settings. type :: yaml_document type ( yaml_node ), pointer :: root => null () !< Root node of document tree end type yaml_document !> Error handling type for YAML operations !! !! Used to track and report errors during YAML processing. type :: yaml_error logical :: has_error = . false . !< True if error occurred character ( len = 256 ) :: message = '' !< Error message text end type yaml_error end module yaml_types","tags":"","loc":"sourcefile/yaml_types.f90.html"},{"title":"yaml_parser.F90 – Fyaml","text":"This file depends on sourcefile~~yaml_parser.f90~~EfferentGraph sourcefile~yaml_parser.f90 yaml_parser.F90 sourcefile~yaml_types.f90 yaml_types.F90 sourcefile~yaml_parser.f90->sourcefile~yaml_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~yaml_parser.f90~~AfferentGraph sourcefile~yaml_parser.f90 yaml_parser.F90 sourcefile~fyaml.f90 fyaml.F90 sourcefile~fyaml.f90->sourcefile~yaml_parser.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> YAML Parser module !! !! This module provides functionality for parsing YAML files into Fortran data structures. !! It handles document structure, value types, indentation, sequences, and mapping nodes. !! !! @note Supports basic YAML features including scalars, sequences, and mappings !! @author Barry Baker !! @version 0.1.0 !! @see yaml_types !! @see fyaml module yaml_parser use yaml_types use iso_fortran_env , only : error_unit , output_unit implicit none ! Debug levels !============= !> Disable all debug output integer , parameter :: DEBUG_NONE = 0 !> Show only error messages integer , parameter :: DEBUG_ERROR = 1 !> Show warnings and errors integer , parameter :: DEBUG_WARN = 2 !> Show general info messages integer , parameter :: DEBUG_INFO = 3 !> Show verbose debug output integer , parameter :: DEBUG_VERBOSE = 4 ! Error codes !============ !> Operation completed successfully integer , parameter :: ERR_SUCCESS = 0 !> YAML file not found or inaccessible integer , parameter :: ERR_FILE_NOT_FOUND = 1 !> Error reading from file integer , parameter :: ERR_READ_ERROR = 2 !> Error parsing YAML content integer , parameter :: ERR_PARSE_ERROR = 3 !> Memory allocation error integer , parameter :: ERR_MEMORY = 4 ! Module variables !================= integer :: debug_level = DEBUG_ERROR contains !> Set the debug output level !! !! Controls how much debug information is printed during parsing !! !! @param[in] level Debug level (DEBUG_NONE through DEBUG_VERBOSE) subroutine set_debug_level ( level ) integer , intent ( in ) :: level debug_level = level end subroutine !> Debug message printer !! !! Prints debug messages based on current debug level !! !! @param[in] level Debug level of message !! @param[in] message Debug message to print !! @param[in] error_code Optional error code to include subroutine debug_print ( level , message , error_code ) integer , intent ( in ) :: level character ( len =* ), intent ( in ) :: message integer , intent ( in ), optional :: error_code if ( level <= debug_level ) then select case ( level ) case ( DEBUG_ERROR ) write ( error_unit , * ) \"ERROR: \" , trim ( message ) if ( present ( error_code )) write ( error_unit , * ) \"Error code:\" , error_code case ( DEBUG_WARN ) write ( error_unit , * ) \"WARNING: \" , trim ( message ) case ( DEBUG_INFO ) write ( output_unit , * ) \"INFO: \" , trim ( message ) case ( DEBUG_VERBOSE ) write ( output_unit , * ) \"DEBUG: \" , trim ( message ) end select endif end subroutine !> Parse a YAML file into document structure !! !! Reads and parses a YAML file into one or more documents !! !! @param[in]  filename Path to YAML file !! @param[out] docs     Array of parsed YAML documents !! @param[out] status   Status code (ERR_SUCCESS on success) subroutine parse_yaml ( filename , docs , status ) character ( len =* ), intent ( in ) :: filename type ( yaml_document ), allocatable , intent ( out ) :: docs (:) integer , intent ( out ) :: status integer :: unit , io_stat , line_count , doc_count character ( len = 1024 ) :: line logical :: in_document , doc_started integer :: i character ( len = 256 ) :: error_msg call debug_print ( DEBUG_INFO , \"Starting YAML parse for: \" // trim ( filename )) status = ERR_SUCCESS ! First pass - count documents open ( newunit = unit , file = filename , status = 'old' , action = 'read' , iostat = io_stat ) if ( io_stat /= 0 ) then write ( error_msg , '(A,I0)' ) \"Failed to open file. IO Status: \" , io_stat call debug_print ( DEBUG_ERROR , error_msg , ERR_FILE_NOT_FOUND ) status = ERR_FILE_NOT_FOUND return endif call debug_print ( DEBUG_VERBOSE , \"Counting documents in file\" ) doc_count = 1 line_count = 0 doc_started = . false . do read ( unit , '(a)' , iostat = io_stat ) line if ( io_stat < 0 ) then call debug_print ( DEBUG_VERBOSE , \"Reached end of file\" ) exit endif if ( io_stat > 0 ) then write ( error_msg , '(A,I0)' ) \"Error reading file at line \" , line_count + 1 call debug_print ( DEBUG_ERROR , error_msg , ERR_READ_ERROR ) close ( unit ) status = ERR_READ_ERROR return endif line_count = line_count + 1 if ( debug_level >= DEBUG_VERBOSE ) then call debug_print ( DEBUG_VERBOSE , \"Processing line \" // trim ( line )) endif ! Skip empty lines and comments at start if (. not . doc_started ) then if ( len_trim ( line ) == 0 . or . line ( 1 : 1 ) == '#' ) cycle doc_started = . true . endif if ( trim ( line ) == '---' ) then if ( doc_started ) doc_count = doc_count + 1 endif enddo if ( line_count == 0 ) then call debug_print ( DEBUG_ERROR , \"Error: Empty file\" , ERR_PARSE_ERROR ) close ( unit ) status = ERR_PARSE_ERROR return endif rewind ( unit ) ! Allocate documents array allocate ( docs ( doc_count )) ! Initialize all documents do i = 1 , doc_count call initialize_document ( docs ( i )) enddo ! Second pass - parse documents doc_count = 1 in_document = . false . doc_started = . false . do read ( unit , '(a)' , iostat = io_stat ) line if ( io_stat < 0 ) exit ! EOF if ( io_stat > 0 ) then write ( error_unit , * ) \"Error reading file:\" , io_stat exit endif ! Skip empty lines and comments if ( len_trim ( line ) == 0 . or . line ( 1 : 1 ) == '#' ) cycle ! Handle document markers if ( trim ( line ) == '---' ) then in_document = . true . if ( doc_started ) doc_count = doc_count + 1 doc_started = . true . cycle endif if ( trim ( line ) == '...' ) then in_document = . false . cycle endif ! Set document started on first content if (. not . doc_started . and . len_trim ( line ) > 0 ) then doc_started = . true . endif ! Parse line into current document if it has content if ( len_trim ( line ) > 0 ) then if ( doc_count <= size ( docs )) then ! Bounds check call parse_line ( line , docs ( doc_count ), status ) if ( status /= ERR_SUCCESS ) then call debug_print ( DEBUG_ERROR , \"Error parsing line\" , status ) close ( unit ) return endif endif endif enddo close ( unit ) ! Handle case where no valid documents were found if (. not . doc_started ) then deallocate ( docs ) call debug_print ( DEBUG_ERROR , \"Error: No valid YAML documents found\" , ERR_PARSE_ERROR ) status = ERR_PARSE_ERROR return endif status = ERR_SUCCESS end subroutine parse_yaml !> Initialize a new YAML document !! !! Sets up empty document structure with nullified root !! !! @param[in,out] doc Document to initialize subroutine initialize_document ( doc ) implicit none type ( yaml_document ), intent ( inout ) :: doc ! Only initialize root node nullify ( doc % root ) end subroutine !> Parse a single line of YAML content !! !! Processes a line and updates document structure. Handles: !! - Indentation !! - Sequence items !! - Key-value pairs !! - Nested structures !! !! @param[in]     line Input line !! @param[in,out] doc  Document being built !! @param[out]    status Status code subroutine parse_line ( line , doc , status ) character ( len =* ), intent ( in ) :: line type ( yaml_document ), intent ( inout ) :: doc integer , intent ( out ) :: status type ( yaml_node ), pointer :: new_node , current_node , parent_node integer :: pos , current_indent , parent_indent , io_stat character ( len = :), allocatable :: local_line logical :: is_sequence_item character ( len = 256 ) :: debug_msg call debug_print ( DEBUG_VERBOSE , \"Parsing line: \" // trim ( line )) ! Validate input if ( len_trim ( line ) == 0 ) then call debug_print ( DEBUG_WARN , \"Empty line received\" ) status = ERR_SUCCESS return endif ! Create local copy and remove comments local_line = trim ( line ) pos = index ( local_line , '#' ) if ( pos > 0 ) local_line = trim ( local_line ( 1 : pos - 1 )) if ( len_trim ( local_line ) == 0 ) return ! Determine indentation and sequence status current_indent = count_leading_spaces ( local_line ) is_sequence_item = ( index ( trim ( local_line ), '-' ) == 1 ) ! Memory allocation and validation checks if (. not . associated ( new_node )) then call debug_print ( DEBUG_ERROR , \"Node pointer not associated\" , ERR_MEMORY ) status = ERR_MEMORY return endif ! Create new node allocate ( new_node , stat = io_stat ) if ( io_stat /= 0 ) then call debug_print ( DEBUG_ERROR , \"Failed to allocate new node\" , ERR_MEMORY ) status = ERR_MEMORY return endif ! Initialize node call initialize_node ( new_node ) call debug_print ( DEBUG_VERBOSE , \"Successfully created and initialized new node\" ) ! Validate node initialization if (. not . associated ( new_node )) then call debug_print ( DEBUG_ERROR , \"Node initialization failed\" , ERR_MEMORY ) status = ERR_MEMORY return endif ! Parse sequence item if ( is_sequence_item ) then new_node % is_sequence = . true . pos = index ( local_line , '-' ) + 1 local_line = trim ( local_line ( pos :)) ! Check for key-value pair in sequence item pos = index ( local_line , ':' ) if ( pos > 0 ) then new_node % key = trim ( local_line ( 1 : pos - 1 )) new_node % value = trim ( local_line ( pos + 1 :)) else new_node % value = trim ( local_line ) endif else ! Parse regular key-value pair pos = index ( local_line , ':' ) if ( pos > 0 ) then new_node % key = trim ( local_line ( 1 : pos - 1 )) new_node % value = trim ( local_line ( pos + 1 :)) else new_node % key = trim ( local_line ) endif endif ! Link node into document structure if (. not . associated ( doc % root )) then doc % root => new_node status = ERR_SUCCESS return endif ! Find correct parent based on indentation current_node => doc % root parent_node => null () parent_indent = 0 do while ( associated ( current_node )) if ( current_indent > parent_indent ) then ! Going deeper in hierarchy if (. not . associated ( current_node % children )) then current_node % children => new_node status = ERR_SUCCESS return endif parent_node => current_node current_node => current_node % children parent_indent = parent_indent + 2 else if ( current_indent == parent_indent ) then ! Same level - add as sibling if (. not . associated ( current_node % next )) then current_node % next => new_node status = ERR_SUCCESS return endif current_node => current_node % next else ! Going back up in hierarchy if ( associated ( parent_node )) then current_node => parent_node parent_node => null () parent_indent = parent_indent - 2 else current_node % next => new_node status = ERR_SUCCESS return endif endif end do end subroutine parse_line !> Parse flow-style YAML syntax !! !! Handles flow-style sequences [...] and mappings {...} !! !! @param[in]     line Input containing flow syntax !! @param[in,out] node Node to store parsed content subroutine parse_flow_form ( line , node ) character ( len =* ), intent ( in ) :: line type ( yaml_node ), pointer , intent ( inout ) :: node ! Changed to pointer integer :: pos , start , end character ( len = :), allocatable :: content ! Handle flow form sequences if ( index ( line , '[' ) > 0 ) then start = index ( line , '[' ) end = index ( line , ']' ) if ( end > start ) then content = trim ( line ( start + 1 : end - 1 )) ! Node is now a pointer, can be passed directly call parse_sequence ( content , node ) end if end if ! Handle flow form mappings if ( index ( line , '{' ) > 0 ) then start = index ( line , '{' ) end = index ( line , '}' ) if ( end > start ) then content = trim ( line ( start + 1 : end - 1 )) call parse_mapping ( content , node ) end if end if end subroutine parse_flow_form !> Parse sequence elements from flow style !! !! Splits comma-separated sequence items into nodes !! !! @param[in,out] content Sequence content string !! @param[in,out] node Node to store sequence subroutine parse_sequence ( content , node ) ! Modified parameter declarations character ( len = :), allocatable , intent ( inout ) :: content type ( yaml_node ), pointer , intent ( inout ) :: node ! Local variables character ( len = :), allocatable :: item character ( len = :), allocatable :: local_content integer :: pos ! Copy input content to local variable for manipulation local_content = content ! Split the content by commas to get individual items do pos = index ( local_content , ',' ) if ( pos > 0 ) then item = trim ( local_content ( 1 : pos - 1 )) local_content = trim ( local_content ( pos + 1 :)) else item = trim ( local_content ) local_content = '' end if ! Create a new node for each item allocate ( node % children ) call initialize_node ( node % children ) node % children % value = item node => node % children if ( len ( local_content ) == 0 ) exit end do ! Update the original content content = local_content end subroutine parse_sequence !> Parse mapping elements from flow style !! !! Splits comma-separated key-value pairs into nodes !! !! @param[in,out] content Mapping content string !! @param[in,out] node Node to store mapping subroutine parse_mapping ( content , node ) character ( len =* ), intent ( inout ) :: content type ( yaml_node ), pointer , intent ( inout ) :: node character ( len = :), allocatable :: key , value character ( len = :), allocatable :: local_content , pair integer :: pos , content_len ! Safely initialize local content content_len = len_trim ( content ) if ( content_len == 0 ) return allocate ( character ( len = content_len ) :: local_content ) local_content = trim ( content ) ! Process key-value pairs do while ( len_trim ( local_content ) > 0 ) ! Get next pair pos = index ( local_content , ',' ) if ( pos > 0 ) then if ( allocated ( pair )) deallocate ( pair ) allocate ( character ( len = pos - 1 ) :: pair ) pair = trim ( local_content ( 1 : pos - 1 )) local_content = trim ( local_content ( pos + 1 :)) else if ( allocated ( pair )) deallocate ( pair ) allocate ( character ( len = len_trim ( local_content )) :: pair ) pair = trim ( local_content ) local_content = '' end if ! Process key-value pair pos = index ( pair , ':' ) if ( pos > 0 ) then if ( allocated ( key )) deallocate ( key ) if ( allocated ( value )) deallocate ( value ) allocate ( character ( len = pos - 1 ) :: key ) allocate ( character ( len = len_trim ( pair ) - pos ) :: value ) key = trim ( pair ( 1 : pos - 1 )) value = trim ( pair ( pos + 1 :)) ! Create new node allocate ( node % children ) call initialize_node ( node % children ) node % children % key = key node % children % value = value node => node % children end if end do ! Clean up if ( allocated ( local_content )) deallocate ( local_content ) if ( allocated ( key )) deallocate ( key ) if ( allocated ( value )) deallocate ( value ) if ( allocated ( pair )) deallocate ( pair ) end subroutine parse_mapping !> Initialize a new YAML node !! !! Sets default values for a newly created node !! !! @param[in,out] node Node to initialize subroutine initialize_node ( node ) type ( yaml_node ), pointer , intent ( inout ) :: node node % key = '' node % value = '' node % children => null () node % next => null () node % is_sequence = . false . node % is_null = . false . node % is_boolean = . false . node % is_integer = . false . node % is_float = . false . node % is_string = . true . end subroutine initialize_node !> Determine value type of node !! !! Checks content and sets appropriate type flags !! !! @param[in,out] node Node to analyze subroutine determine_value_type ( node ) type ( yaml_node ), intent ( inout ) :: node real :: r_value integer :: i_value logical :: l_value logical :: is_real , is_int integer :: rc character ( len = 32 ) :: temp_str ! Buffer for numeric conversions ! Early exit for empty values if ( len_trim ( node % value ) == 0 ) then node % is_null = . true . return end if ! Check for null values if ( to_lower ( trim ( node % value )) == 'null' . or . & trim ( node % value ) == '~' . or . & to_lower ( trim ( node % value )) == 'nan' ) then node % is_null = . true . node % value = '' return end if ! Check for boolean values if ( trim ( node % value ) == 'true' . or . trim ( node % value ) == 'false' ) then node % is_boolean = . true . l_value = ( trim ( node % value ) == 'true' ) write ( temp_str , '(L1)' , iostat = rc ) l_value if ( rc == 0 ) node % value = trim ( temp_str ) return end if ! Check for float values if ( is_real_string ( trim ( node % value ))) then read ( node % value , * , iostat = rc ) r_value if ( rc == 0 ) then node % is_float = . true . write ( temp_str , '(G14.6)' , iostat = rc ) r_value if ( rc == 0 ) node % value = trim ( temp_str ) return end if end if ! Check for integer values if ( is_int_string ( trim ( node % value ))) then read ( node % value , * , iostat = rc ) i_value if ( rc == 0 ) then node % is_integer = . true . write ( temp_str , '(I0)' , iostat = rc ) i_value if ( rc == 0 ) node % value = trim ( temp_str ) return end if end if ! Default to string node % is_string = . true . end subroutine determine_value_type !> Count leading spaces in a string !! !! Used for determining indentation level !! !! @param[in]  line Input string !! @return     Number of leading spaces integer function count_leading_spaces ( line ) implicit none character ( len =* ), intent ( in ) :: line integer :: i count_leading_spaces = 0 do i = 1 , len ( line ) if ( line ( i : i ) /= ' ' ) exit count_leading_spaces = count_leading_spaces + 1 end do end function count_leading_spaces !> Check if string can be parsed as real number !! !! @param[in]  str String to check !! @return     True if string represents a real number function is_real_string ( str ) result ( is_real ) implicit none character ( len =* ), intent ( in ) :: str logical :: is_real real :: r_value integer :: iostat read ( str , * , iostat = iostat ) r_value if ( iostat == 0 ) then is_real = . true . else is_real = . false . end if end function is_real_string !> Check if string represents an integer !! !! @param[in] str String to check !! @return True if string can be parsed as integer function is_int_string ( str ) result ( is_int ) implicit none character ( len =* ), intent ( in ) :: str logical :: is_int integer :: i_value integer :: iostat read ( str , * , iostat = iostat ) i_value if ( iostat == 0 ) then is_int = . true . else is_int = . false . end if end function is_int_string !> Convert string to lowercase !! !! @param[in]  str Input string !! @return     Lowercase version of input function to_lower ( str ) result ( lower_str ) implicit none character ( len =* ), intent ( in ) :: str character ( len = len ( str )) :: lower_str integer :: i lower_str = str do i = 1 , len ( str ) if ( iachar ( str ( i : i )) >= iachar ( 'A' ) . and . iachar ( str ( i : i )) <= iachar ( 'Z' )) then lower_str ( i : i ) = achar ( iachar ( str ( i : i )) + 32 ) end if end do end function to_lower !> Validate node structure and contents !! !! Performs validation checks on node pointers and content !! !! @param[in] node Node to validate !! @param[out] status Status code (ERR_SUCCESS if valid) subroutine validate_node ( node , status ) type ( yaml_node ), pointer , intent ( in ) :: node integer , intent ( out ) :: status if (. not . associated ( node )) then call debug_print ( DEBUG_ERROR , \"Invalid node pointer\" , ERR_PARSE_ERROR ) status = ERR_PARSE_ERROR return endif ! Validate node contents if ( node % is_sequence . and . . not . associated ( node % children )) then call debug_print ( DEBUG_WARN , \"Sequence node without children\" ) endif status = ERR_SUCCESS end subroutine validate_node end module yaml_parser","tags":"","loc":"sourcefile/yaml_parser.f90.html"},{"title":"fyaml.F90 – Fyaml","text":"This file depends on sourcefile~~fyaml.f90~~EfferentGraph sourcefile~fyaml.f90 fyaml.F90 sourcefile~yaml_parser.f90 yaml_parser.F90 sourcefile~fyaml.f90->sourcefile~yaml_parser.f90 sourcefile~yaml_types.f90 yaml_types.F90 sourcefile~fyaml.f90->sourcefile~yaml_types.f90 sourcefile~yaml_parser.f90->sourcefile~yaml_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> A modern Fortran module for parsing YAML files !! !! This module provides functionality to read and parse YAML files into Fortran !! data structures. It supports nested dictionaries, sequences, and various data types. !! !! @note Currently supports strings, integers, reals, booleans, nulls, sequences and nested structures !! @author Barry Baker !! @date 2024 !! @version 0.1.0 !! @copyright GNU GENERAL PUBLIC LICENSE v3.0 module fyaml use yaml_parser use yaml_types use , intrinsic :: iso_fortran_env , only : error_unit implicit none private public :: fyaml_doc , yaml_value , yaml_dict , yaml_pair , yaml_wrapper , error_unit !> Constants for supported YAML value types integer , parameter :: TYPE_STRING = 1 !< String type integer , parameter :: TYPE_REAL = 2 !< Real number type integer , parameter :: TYPE_INTEGER = 3 !< Integer type integer , parameter :: TYPE_BOOLEAN = 4 !< Boolean type integer , parameter :: TYPE_NULL = 5 !< Null type integer , parameter :: TYPE_SEQUENCE = 6 !< Sequence type integer , parameter :: TYPE_DICT = 7 !< Dictionary type !> Value container type supporting multiple YAML data types type :: yaml_value character ( len = :), allocatable :: str_val !< String value real :: real_val !< Real number value integer :: int_val !< Integer value logical :: bool_val !< Boolean value logical :: is_null = . false . !< Null indicator character ( len = :), allocatable , dimension (:) :: sequence !< Sequence value integer :: value_type = 0 !< Type indicator type ( yaml_dict ), pointer :: dict_val => null () !< Dictionary value contains procedure :: get => get_nested_value !< Get value using dot notation path end type yaml_value !> Dictionary key-value pair type type :: yaml_pair character ( len = :), allocatable :: key !< Dictionary key type ( yaml_value ) :: value !< Value container type ( yaml_dict ), pointer :: nested => null () !< Nested dictionary type ( yaml_pair ), pointer :: next => null () !< Next pair in linked list end type yaml_pair !> Dictionary container type type :: yaml_dict type ( yaml_pair ), pointer :: first => null () !< First key-value pair integer :: count = 0 !< Number of entries contains procedure :: get => get_value !< Get value by key procedure :: set => set_value !< Set value for key procedure :: keys => get_keys !< Get all keys end type yaml_dict !> YAML document container type :: fyaml_doc type ( yaml_dict ) :: root !< Root dictionary contains procedure :: load => load_yaml_doc !< Load YAML from file end type fyaml_doc !> YAML document wrapper with raw and processed forms type :: yaml_wrapper type ( yaml_document ) :: raw_doc !< Raw YAML document type ( fyaml_doc ) :: doc !< Processed document type ( yaml_dict ) :: dict !< Dictionary structure contains procedure :: load => load_yaml_wrapper !< Load and process YAML procedure :: convert => convert_to_dict !< Convert raw to dictionary end type yaml_wrapper contains !> Load YAML document from file !! !! @param[in,out] this     The document instance !! @param[in]     filename Path to YAML file !! @param[out]    success  Optional success indicator subroutine load_yaml_doc ( this , filename , success ) class ( fyaml_doc ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: filename logical , intent ( out ), optional :: success type ( yaml_document ), allocatable :: parsed_docs (:) logical :: ok integer :: unit , iostat ok = . false . ! Check if file exists and is readable open ( newunit = unit , file = filename , status = 'old' , action = 'read' , iostat = iostat ) if ( iostat /= 0 ) then write ( error_unit , * ) 'Error opening file:' , trim ( filename ) if ( present ( success )) success = . false . return end if close ( unit ) ! Parse YAML call parse_yaml ( filename , parsed_docs ) if ( allocated ( parsed_docs )) then if ( associated ( parsed_docs ( 1 )% root )) then call convert_node_to_dict ( parsed_docs ( 1 )% root , this % root ) ok = . true . end if deallocate ( parsed_docs ) end if if ( present ( success )) success = ok end subroutine load_yaml_doc !> Load and process YAML document through wrapper !! !! @param[in,out] this     The wrapper instance !! @param[in]     filename Path to YAML file subroutine load_yaml_wrapper ( this , filename ) class ( yaml_wrapper ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: filename call this % doc % load ( filename ) call this % convert () end subroutine load_yaml_wrapper !> Parse a YAML sequence string into array !! !! @param[in]  str Input sequence string in format '[item1,item2,...]' !! @return     Array of sequence items function fyaml_parse_sequence ( str ) result ( seq ) character ( len =* ), intent ( in ) :: str character ( len = :), allocatable , dimension (:) :: seq integer :: n , i , start , end n = count ( transfer ( str , 'a' , len ( str )) == ',' ) + 1 allocate ( character ( len = 32 ) :: seq ( n )) start = 2 ! Skip '[' do i = 1 , n end = index ( str ( start :), ',' ) - 1 if ( end < 0 ) end = len_trim ( str ) - 1 ! Last item seq ( i ) = trim ( adjustl ( str ( start : start + end - 1 ))) start = start + end + 2 end do end function fyaml_parse_sequence !> Recursively convert YAML node structure to dictionary !! !! @param[in]     node Input YAML node !! @param[in,out] dict Output dictionary structure recursive subroutine convert_node_to_dict ( node , dict ) type ( yaml_node ), pointer , intent ( in ) :: node type ( yaml_dict ), intent ( inout ) :: dict type ( yaml_pair ), pointer :: new_pair type ( yaml_node ), pointer :: current current => node do while ( associated ( current )) allocate ( new_pair ) new_pair % key = current % key if ( associated ( current % children )) then allocate ( new_pair % nested ) new_pair % value % value_type = TYPE_DICT new_pair % value % dict_val => new_pair % nested call convert_node_to_dict ( current % children , new_pair % nested ) else ! Set value based on content if ( is_sequence ( current % value )) then new_pair % value % value_type = TYPE_SEQUENCE new_pair % value % sequence = fyaml_parse_sequence ( current % value ) else if ( is_null ( current % value )) then new_pair % value % value_type = TYPE_NULL new_pair % value % is_null = . true . else if ( is_boolean ( current % value )) then new_pair % value % value_type = TYPE_BOOLEAN new_pair % value % bool_val = current % value == 'true' ! Direct comparison instead of parse_sequence else if ( is_number ( current % value )) then if ( index ( current % value , '.' ) > 0 ) then new_pair % value % value_type = TYPE_REAL read ( current % value , * ) new_pair % value % real_val else new_pair % value % value_type = TYPE_INTEGER read ( current % value , * ) new_pair % value % int_val endif else new_pair % value % value_type = TYPE_STRING new_pair % value % str_val = current % value endif endif if (. not . associated ( dict % first )) then dict % first => new_pair else new_pair % next => dict % first dict % first => new_pair endif dict % count = dict % count + 1 current => current % next end do end subroutine convert_node_to_dict !> Set value for a given key in dictionary !! !! @param[in,out] this  The dictionary instance !! @param[in]     key   Key to set !! @param[in]     value Value to associate with key subroutine set_value ( this , key , value ) class ( yaml_dict ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: key type ( yaml_value ), intent ( in ) :: value type ( yaml_pair ), pointer :: current , new_pair ! Check if key exists current => this % first do while ( associated ( current )) if ( current % key == key ) then ! Update existing value current % value = value return endif current => current % next end do ! Key doesn't exist, create new pair allocate ( new_pair ) new_pair % key = key new_pair % value = value ! Add to beginning of list new_pair % next => this % first this % first => new_pair this % count = this % count + 1 end subroutine set_value !> Check if string represents a sequence !! !! @param[in]  str String to check !! @return     True if string starts with '[' function is_sequence ( str ) result ( res ) character ( len =* ), intent ( in ) :: str logical :: res res = str ( 1 : 1 ) == '[' end function is_sequence !> Check if string represents null !! !! @param[in]  str String to check !! @return     True if string equals 'null' function is_null ( str ) result ( res ) character ( len =* ), intent ( in ) :: str logical :: res res = trim ( str ) == 'null' end function is_null !> Check if string represents boolean !! !! @param[in]  str String to check !! @return     True if string equals 'true' or 'false' function is_boolean ( str ) result ( res ) character ( len =* ), intent ( in ) :: str logical :: res res = trim ( str ) == 'true' . or . trim ( str ) == 'false' end function is_boolean !> Check if string represents a number !! !! @param[in]  str String to check !! @return     True if string contains only digits, dot or minus function is_number ( str ) result ( res ) character ( len =* ), intent ( in ) :: str logical :: res res = verify ( trim ( str ), '0123456789.-' ) == 0 end function is_number !> Get value associated with key from dictionary !! !! @param[in]  this Dictionary instance !! @param[in]  key  Key to lookup !! @return     Value associated with key function get_value ( this , key ) result ( val ) class ( yaml_dict ), intent ( in ) :: this character ( len =* ), intent ( in ) :: key type ( yaml_value ) :: val type ( yaml_pair ), pointer :: current current => this % first do while ( associated ( current )) if ( current % key == key ) then val = current % value return endif current => current % next end do end function get_value !> Get all keys in dictionary !! !! @param[in]  this Dictionary instance !! @return     Array of all keys function get_keys ( this ) result ( keys ) class ( yaml_dict ), intent ( in ) :: this character ( len = :), allocatable , dimension (:) :: keys type ( yaml_pair ), pointer :: current integer :: i allocate ( character ( len = 32 ) :: keys ( this % count )) current => this % first i = 1 do while ( associated ( current )) keys ( i ) = current % key i = i + 1 current => current % next end do end function get_keys !> Convert raw YAML document to dictionary structure !! !! @param[in,out] this Wrapper instance containing raw and processed forms subroutine convert_to_dict ( this ) class ( yaml_wrapper ), intent ( inout ) :: this ! Convert from raw yaml_document to yaml_dict structure if ( associated ( this % raw_doc % root )) then call convert_node_to_dict ( this % raw_doc % root , this % dict ) endif end subroutine convert_to_dict !> Get nested value using dot notation path !! !! @param[in]  self YAML value instance !! @param[in]  key  Dot-separated path (e.g. \"database.host\") !! @return     Value at specified path recursive function get_nested_value ( self , key ) result ( val ) class ( yaml_value ), intent ( in ) :: self character ( len =* ), intent ( in ) :: key type ( yaml_value ) :: val integer :: dot_pos character ( len = :), allocatable :: first_key , rest_path dot_pos = index ( key , \".\" ) if ( dot_pos > 0 ) then first_key = key ( 1 : dot_pos - 1 ) rest_path = key ( dot_pos + 1 :) if ( associated ( self % dict_val )) then val = self % dict_val % get ( first_key ) if (. not . val % is_null . and . allocated ( rest_path )) then val = val % get ( rest_path ) endif else val % is_null = . true . endif else if ( associated ( self % dict_val )) then val = self % dict_val % get ( key ) else val % is_null = . true . endif endif end function get_nested_value end module fyaml","tags":"","loc":"sourcefile/fyaml.f90.html"},{"title":"Fyaml – Fyaml","text":"Fyaml: Modern YAML Parser for Fortran Overview Fyaml provides a robust, easy-to-use YAML parser for Fortran applications. It handles complex YAML structures while maintaining type safety and memory efficiency. Getting Started Installation git clone https://github.com/yourusername/fyaml.git cd fyaml\nmkdir build && cd build\ncmake ..\nmake install Basic Usage Read a Yaml Configuration file: # config.yaml server : host : localhost ports : - 8080 - 8081 settings : timeout : 30 debug : true Parse it in your Fortran code: program example use fyaml type ( fyaml_doc ) :: doc type ( yaml_value ) :: val integer , allocatable :: ports (:) ! Load configuration call doc % load ( \"config.yaml\" ) ! Access string values val = doc % root % get ( \"server.host\" ) print * , \"Host:\" , val % str_val ! Access arrays val = doc % root % get ( \"server.ports\" ) ports = val % int_array print * , \"Ports:\" , ports ! Access nested values val = doc % root % get ( \"server.settings.timeout\" ) print * , \"Timeout:\" , val % int_val end program Core Features Type Safety: Native Fortran type handling Memory Management: Automatic cleanup of resources Flexible Access: Dot notation for nested structures Rich Data Types: Support for: Strings Integers Real numbers Booleans Arrays Nested structures Null values API Documentation Core Modules yaml_types - Core type definitions and data structures yaml_parser - YAML parsing implementation fyaml - High-level interface Key Types ! Document container type :: fyaml_doc type ( yaml_dict ) :: root contains procedure :: load end type ! Value container type :: yaml_value integer :: value_type character ( len = :), allocatable :: str_val integer :: int_val real :: real_val logical :: bool_val type ( yaml_dict ), pointer :: dict_val => null () end type Advanced Usage Error Handling program error_handling use fyaml type ( fyaml_doc ) :: doc integer :: status call doc % load ( \"config.yaml\" , status ) if ( status /= 0 ) then print * , \"Failed to load configuration\" stop 1 endif end program Working with Arrays ! Read sequence of values val = doc % get ( \"database.ports\" ) if ( val % is_sequence ()) then ports = val % int_array endif Debug Output with Configurable Levels use yaml_parser , only : set_debug_level , DEBUG_VERBOSE call set_debug_level ( DEBUG_VERBOSE ) Examples See our examples directory for: Basic configuration reading Complex data structures Error handling Type conversion Array handling Contributing We welcome contributions! See our contribution guidelines. License Licensed under GNU General Public License v3.0","tags":"","loc":"page/index.html"}]}