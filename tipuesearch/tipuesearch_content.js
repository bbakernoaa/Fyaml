var tipuesearch = {"pages":[{"title":" Fyaml ","text":"Fyaml fyaml - A Modern Fortran YAML Parser A feature-rich YAML parser written in modern Fortran, supporting complex data structures and designed for scientific computing applications. Key Features Comprehensive YAML Support Full support for YAML 1.2 specification Multi-document processing Complex nested structures Sequence and mapping support Rich Data Type Support Strings, integers, floats (single/double precision) Booleans with multiple formats (true/false, yes/no, on/off) Date and time parsing Null values Multi-line strings Advanced Features Dot notation for nested access (e.g., \"config.database.host\") Array and sequence iteration Automatic type conversion Memory-safe implementation Error handling with detailed messages Requirements Fortran 2008 compliant compiler (gfortran 8.0+ or ifort 19.0+) CMake 3.12+ Installation git clone https://github.com/yourusername/fyaml.git cd fyaml\nmkdir build && cd build\ncmake ..\nmake\nmake install Usage Examples 1) Create a complex YAML configuration: simulation : parameters : timestep : 0.01 max_iterations : 1000 tolerances : - 1.0e-6 - 1.0e-8 output : format : netcdf variables : [ temperature , pressure , velocity ] frequency : 100 2) Parse and access data: program simulation_setup use fyaml type ( fyaml_doc ) :: config type ( yaml_value ) :: val real ( dp ) :: timestep character ( len = :), allocatable , dimension (:) :: variables ! Load configuration call config % load ( \"simulation.yaml\" ) ! Get scalar values using dot notation timestep = config % get ( \"simulation.parameters.timestep\" )% get_real () ! Get array of strings variables = config % get ( \"simulation.output.variables\" )% get_string_array () ! Check if a key exists if ( config % has_key ( \"simulation.output.format\" )) then print * , \"Output format:\" , config % get ( \"simulation.output.format\" )% get_str () end if end program 3) Working with sequences and mappings: ! Iterate over sequence type ( yaml_value ) :: tolerances tolerances = config % get ( \"simulation.parameters.tolerances\" ) if ( tolerances % is_sequence ()) then do i = 1 , tolerances % size () print * , \"Tolerance\" , i , \":\" , tolerances % get ( i )% get_real () end do end if 4) Getting all keys from a YAML document: # Example configuration database : host : localhost port : 5432 logging : level : debug file : app.log program key_example use fyaml type ( fyaml_doc ) :: config type ( yaml_value ) :: root_value , db_value character ( len = :), allocatable , dimension (:) :: root_keys , db_keys ! Load configuration call config % load ( \"config.yaml\" ) ! Get all root level keys root_value = config % root root_keys = root_value % get_keys () print * , \"Root level keys:\" , root_keys ! Will print: database, logging ! Get keys from nested section db_value = config % get ( \"database\" ) db_keys = db_value % get_keys () print * , \"Database keys:\" , db_keys ! Will print: host, port ! Check if specific keys exist if ( root_value % has_key ( \"database\" )) then print * , \"Database configuration found!\" end if end program Error Handling logical :: success character ( len = :), allocatable :: error_msg call config % load ( \"config.yaml\" , success , error_msg ) if (. not . success ) then print * , \"Error loading YAML:\" , error_msg error stop end if Testing ctest --test-dir build/tests --output-on-failure Documentation Documentation is generated using FORD. To build: ford docs.md License GNU General Public License v3.0 Contributing Contributions welcome! Please read CONTRIBUTING.md for guidelines. Disclaimer The United States Department of Commerce (DOC) GitHub project code is\nprovided on an 'as is' basis and the user assumes responsibility for\nits use.  DOC has relinquished control of the information and no\nlonger has responsibility to protect the integrity, confidentiality,\nor availability of the information.  Any claims against the Department\nof Commerce stemming from the use of its GitHub project will be\ngoverned by all applicable Federal law.  Any reference to specific\ncommercial products, processes, or services by service mark,\ntrademark, manufacturer, or otherwise, does not constitute or imply\ntheir endorsement, recommendation or favoring by the Department of\nCommerce.  The Department of Commerce seal and logo, or the seal and\nlogo of a DOC bureau, shall not be used in any manner to imply\nendorsement of any commercial product or activity by DOC or the United\nStates Government. Developer Info Barry Baker and Zach Moon","tags":"home","loc":"index.html"},{"title":"indent_tracker – Fyaml ","text":"type, public :: indent_tracker Components Type Visibility Attributes Name Initial integer, public :: indent character(len=:), public, allocatable :: last_key integer, public :: line_num type( indent_tracker ), public, pointer :: next => null()","tags":"","loc":"type/indent_tracker.html"},{"title":"stack_entry – Fyaml ","text":"type, public :: stack_entry Inherits type~~stack_entry~~InheritsGraph type~stack_entry stack_entry type~yaml_node yaml_node type~stack_entry->type~yaml_node node type~yaml_node->type~yaml_node children, next, parent Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( yaml_node ), public, pointer :: node => null()","tags":"","loc":"type/stack_entry.html"},{"title":"fyaml_doc – Fyaml ","text":"type, public :: fyaml_doc Main document type for YAML parsing Represents a complete YAML document with support for multiple documents Inherits type~~fyaml_doc~~InheritsGraph type~fyaml_doc fyaml_doc type~yaml_dict yaml_dict type~fyaml_doc->type~yaml_dict docs type~yaml_pair yaml_pair type~yaml_dict->type~yaml_pair first type~yaml_pair->type~yaml_dict nested type~yaml_pair->type~yaml_pair next type~yaml_value yaml_value type~yaml_pair->type~yaml_value value type~yaml_node yaml_node type~yaml_value->type~yaml_node node type~yaml_node->type~yaml_node children, next, parent Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( yaml_dict ), public, allocatable :: docs (:) integer, public :: n_docs = 0 Type-Bound Procedures procedure, public :: get => get_doc_nested private recursive function get_doc_nested(self, path, doc_index) result(val) Get nested value for fyaml_doc type @param[in] self Document instance\n@param[in] path Nested path with % delimiters\n@param[in] doc_index Optional document index\n@return Value at nested path Arguments Type Intent Optional Attributes Name class( fyaml_doc ), intent(inout) :: self character(len=*), intent(in) :: path integer, intent(in), optional :: doc_index Return Value type( yaml_value ) procedure, public :: get_bool => get_nested_bool private  function get_nested_bool(self, path, doc_index) result(val) Get nested boolean value @param[in] self Document instance\n@param[in] path Nested path with % delimiters\n@param[in] doc_index Optional document index\n@return Boolean value at nested path Arguments Type Intent Optional Attributes Name class( fyaml_doc ), intent(inout) :: self character(len=*), intent(in) :: path integer, intent(in), optional :: doc_index Return Value logical procedure, public :: get_default_doc private  function get_default_doc(this) result(val) Get value from default document (first document) @param[in] this Document collection\n@return First document in collection Arguments Type Intent Optional Attributes Name class( fyaml_doc ), intent(in) :: this Return Value type( yaml_dict ) procedure, public :: get_doc => get_document private  function get_document(this, doc_index) result(val) Get specific document by index @param[in] this Document collection\n@param[in] doc_index Index of document to get\n@return Document at specified index Arguments Type Intent Optional Attributes Name class( fyaml_doc ), intent(in) :: this integer, intent(in) :: doc_index Return Value type( yaml_dict ) procedure, public :: get_int => get_nested_int private  function get_nested_int(self, path, doc_index) result(val) Get nested integer value @param[in] self Document instance\n@param[in] path Nested path with % delimiters\n@param[in] doc_index Optional document index\n@return Integer value at nested path Arguments Type Intent Optional Attributes Name class( fyaml_doc ), intent(inout) :: self character(len=*), intent(in) :: path integer, intent(in), optional :: doc_index Return Value integer procedure, public :: get_real => get_nested_real private  function get_nested_real(self, path, doc_index) result(val) Get nested real value @param[in] self Document instance\n@param[in] path Nested path with % delimiters\n@param[in] doc_index Optional document index\n@return Real value at nested path Arguments Type Intent Optional Attributes Name class( fyaml_doc ), intent(inout) :: self character(len=*), intent(in) :: path integer, intent(in), optional :: doc_index Return Value real procedure, public :: get_str => get_nested_str private  function get_nested_str(self, path, doc_index) result(val) Get nested string value @param[in] self Document instance\n@param[in] path Nested path with % delimiters\n@param[in] doc_index Optional document index\n@return String value at nested path Arguments Type Intent Optional Attributes Name class( fyaml_doc ), intent(inout) :: self character(len=*), intent(in) :: path integer, intent(in), optional :: doc_index Return Value character(len=:), allocatable procedure, public :: load => load_yaml_doc private  subroutine load_yaml_doc(this, filename, success) Load YAML document from file @param[in,out] this     The document instance\n@param[in]     filename Path to YAML file\n@param[out]    success  Optional success indicator Arguments Type Intent Optional Attributes Name class( fyaml_doc ), intent(inout) :: this character(len=*), intent(in) :: filename logical, intent(out), optional :: success procedure, public :: root_keys => get_root_keys public  function get_root_keys (this) result(keys) Get all root keys from the document Read more… Arguments Type Intent Optional Attributes Name class( fyaml_doc ), intent(in) :: this Return Value character(len=:), allocatable, dimension(:)","tags":"","loc":"type/fyaml_doc.html"},{"title":"yaml_dict – Fyaml ","text":"type, public :: yaml_dict Dictionary container type Manages a collection of key-value pairs in a linked list structure Inherits type~~yaml_dict~~InheritsGraph type~yaml_dict yaml_dict type~yaml_pair yaml_pair type~yaml_dict->type~yaml_pair first type~yaml_pair->type~yaml_dict nested type~yaml_pair->type~yaml_pair next type~yaml_value yaml_value type~yaml_pair->type~yaml_value value type~yaml_node yaml_node type~yaml_value->type~yaml_node node type~yaml_node->type~yaml_node children, next, parent Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~yaml_dict~~InheritedByGraph type~yaml_dict yaml_dict type~yaml_pair yaml_pair type~yaml_dict->type~yaml_pair first type~fyaml_doc fyaml_doc type~fyaml_doc->type~yaml_dict docs type~yaml_pair->type~yaml_dict nested type~yaml_pair->type~yaml_pair next Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: count = 0 type( yaml_pair ), public, pointer :: first => null() Type-Bound Procedures procedure, public :: get => get_value private  function get_value(this, key) result(val) Get value associated with key from dictionary @param[in] this Dictionary instance\n@param[in] key Key to lookup\n@return Value associated with key Arguments Type Intent Optional Attributes Name class( yaml_dict ), intent(inout) :: this character(len=*), intent(in) :: key Return Value type( yaml_value ) procedure, public :: keys => get_keys private  function get_keys(this) result(keys) Get all keys in dictionary @param[in]  this Dictionary instance\n@return     Array of all keys Arguments Type Intent Optional Attributes Name class( yaml_dict ), intent(in) :: this Return Value character(len=:), allocatable, dimension(:) procedure, public :: set => set_value private  subroutine set_value(this, key, value) Set value for a given key in dictionary @param[in,out] this  The dictionary instance\n@param[in]     key   Key to set\n@param[in]     value Value to associate with key Arguments Type Intent Optional Attributes Name class( yaml_dict ), intent(inout) :: this character(len=*), intent(in) :: key type( yaml_value ), intent(in) :: value","tags":"","loc":"type/yaml_dict.html"},{"title":"yaml_pair – Fyaml ","text":"type, public :: yaml_pair Dictionary key-value pair type Represents a single key-value entry in a YAML dictionary Inherits type~~yaml_pair~~InheritsGraph type~yaml_pair yaml_pair type~yaml_pair->type~yaml_pair next type~yaml_dict yaml_dict type~yaml_pair->type~yaml_dict nested type~yaml_value yaml_value type~yaml_pair->type~yaml_value value type~yaml_dict->type~yaml_pair first type~yaml_node yaml_node type~yaml_value->type~yaml_node node type~yaml_node->type~yaml_node children, next, parent Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~yaml_pair~~InheritedByGraph type~yaml_pair yaml_pair type~yaml_pair->type~yaml_pair next type~yaml_dict yaml_dict type~yaml_pair->type~yaml_dict nested type~yaml_dict->type~yaml_pair first type~fyaml_doc fyaml_doc type~fyaml_doc->type~yaml_dict docs Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: indent_level = 0 character(len=:), public, allocatable :: key type( yaml_dict ), public, pointer :: nested => null() type( yaml_pair ), public, pointer :: next => null() type( yaml_value ), public :: value","tags":"","loc":"type/yaml_pair.html"},{"title":"yaml_value – Fyaml ","text":"type, public :: yaml_value Value container type supporting multiple YAML data types Wraps a yaml_node pointer and provides type-safe access methods Inherits type~~yaml_value~~InheritsGraph type~yaml_value yaml_value type~yaml_node yaml_node type~yaml_value->type~yaml_node node type~yaml_node->type~yaml_node children, next, parent Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~yaml_value~~InheritedByGraph type~yaml_value yaml_value type~yaml_pair yaml_pair type~yaml_pair->type~yaml_value value type~yaml_pair->type~yaml_pair next type~yaml_dict yaml_dict type~yaml_pair->type~yaml_dict nested type~yaml_dict->type~yaml_pair first type~fyaml_doc fyaml_doc type~fyaml_doc->type~yaml_dict docs Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( yaml_node ), public, pointer :: node => null() Type-Bound Procedures procedure, public :: child_at => get_child_at_index private  function get_child_at_index(self, idx) result(val) Get child value at specified index @param[in] self Value container instance\n@param[in] idx Index of child to retrieve (1-based)\n@return Value container for child at index or null if invalid Arguments Type Intent Optional Attributes Name class( yaml_value ), intent(in) :: self integer, intent(in) :: idx Return Value type( yaml_value ) procedure, public :: child_keys => get_value_child_keys private  function get_value_child_keys(val) result(keys) Get all child keys of a yaml_value @param[in] val Value to get children from\n@return Array of child key names Arguments Type Intent Optional Attributes Name class( yaml_value ), intent(in) :: val Return Value character(len=:), allocatable, dimension(:) procedure, public :: get => get_value_nested private recursive function get_value_nested(self, key) result(val) Get nested value for yaml_value type @param[in] self Value container instance\n@param[in] key Nested key path with % delimiters\n@return Value at nested path Arguments Type Intent Optional Attributes Name class( yaml_value ), intent(inout) :: self character(len=*), intent(in) :: key Return Value type( yaml_value ) procedure, public :: get_bool => get_boolean_value private  function get_boolean_value(self) result(bool_val) Get boolean value from yaml_value @param[in] self Value container instance\n@return Boolean value or false if invalid Arguments Type Intent Optional Attributes Name class( yaml_value ), intent(inout) :: self Return Value logical procedure, public :: get_int => get_integer_value private  function get_integer_value(self) result(int_val) Get integer value from yaml_value @param[in] self Value container instance\n@return Integer value or 0 if invalid Arguments Type Intent Optional Attributes Name class( yaml_value ), intent(inout) :: self Return Value integer procedure, public :: get_real => get_real_value private  function get_real_value(self) result(real_val) Get real value from yaml_value @param[in] self Value container instance\n@return Real value or 0.0 if invalid Arguments Type Intent Optional Attributes Name class( yaml_value ), intent(inout) :: self Return Value real procedure, public :: get_sequence => get_sequence_values private  function get_sequence_values(self) result(values) Get sequence values as an array of strings @param[in] self Value container instance\n@return Array of sequence values as strings Arguments Type Intent Optional Attributes Name class( yaml_value ), intent(in) :: self Return Value character(len=:), allocatable, dimension(:) procedure, public :: get_sequence_bool => get_sequence_bools private  function get_sequence_bools(self) result(values) Get sequence values as logicals @param[in] self Value container instance\n@return Array of sequence values as logicals Arguments Type Intent Optional Attributes Name class( yaml_value ), intent(in) :: self Return Value logical, allocatable, dimension(:) procedure, public :: get_sequence_int => get_sequence_integers private  function get_sequence_integers(self) result(values) Get sequence values as integers @param[in] self Value container instance\n@return Array of sequence values as integers Arguments Type Intent Optional Attributes Name class( yaml_value ), intent(in) :: self Return Value integer, allocatable, dimension(:) procedure, public :: get_sequence_real => get_sequence_reals private  function get_sequence_reals(self) result(values) Get sequence values as reals @param[in] self Value container instance\n@return Array of sequence values as reals Arguments Type Intent Optional Attributes Name class( yaml_value ), intent(in) :: self Return Value real, allocatable, dimension(:) procedure, public :: get_str => get_string_value private  function get_string_value(self) result(str_val) Get string value from yaml_value @param[in] self Value container instance\n@return String value or empty string if invalid Arguments Type Intent Optional Attributes Name class( yaml_value ), intent(inout) :: self Return Value character(len=:), allocatable procedure, public :: is_null => check_null private  function check_null(self) result(is_null) Check if value is null @param[in] self Value container instance\n@return True if value is null Arguments Type Intent Optional Attributes Name class( yaml_value ), intent(in) :: self Return Value logical procedure, public :: is_sequence => check_sequence_impl private  function check_sequence_impl(self) result(is_seq) Check if value is a sequence @param[in] self Value container instance\n@return True if value is a sequence Arguments Type Intent Optional Attributes Name class( yaml_value ), intent(in) :: self Return Value logical procedure, public :: size => get_sequence_size private  function get_sequence_size(self) result(size) Get the size of a sequence @param[in] self Value container instance\n@return Size of sequence or 0 if not a sequence/invalid Arguments Type Intent Optional Attributes Name class( yaml_value ), intent(in) :: self Return Value integer","tags":"","loc":"type/yaml_value.html"},{"title":"yaml_document – Fyaml ","text":"type, public :: yaml_document Document container type Inherits type~~yaml_document~~InheritsGraph type~yaml_document yaml_document type~yaml_node yaml_node type~yaml_document->type~yaml_node root type~yaml_node->type~yaml_node children, next, parent Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( yaml_node ), public, pointer :: root => null()","tags":"","loc":"type/yaml_document.html"},{"title":"yaml_node – Fyaml ","text":"type, public :: yaml_node Core node type for YAML elements Inherited by type~~yaml_node~~InheritedByGraph type~yaml_node yaml_node type~yaml_node->type~yaml_node children, next, parent type~stack_entry stack_entry type~stack_entry->type~yaml_node node type~yaml_document yaml_document type~yaml_document->type~yaml_node root type~yaml_value yaml_value type~yaml_value->type~yaml_node node type~yaml_pair yaml_pair type~yaml_pair->type~yaml_value value type~yaml_pair->type~yaml_pair next type~yaml_dict yaml_dict type~yaml_pair->type~yaml_dict nested type~yaml_dict->type~yaml_pair first type~fyaml_doc fyaml_doc type~fyaml_doc->type~yaml_dict docs Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( yaml_node ), public, pointer :: children => null() integer, public :: indent = 0 logical, public :: is_boolean = .false. logical, public :: is_float = .false. logical, public :: is_integer = .false. logical, public :: is_null = .false. logical, public :: is_root = .false. logical, public :: is_sequence = .false. logical, public :: is_string = .true. character(len=:), public, allocatable :: key integer, public :: last_child_line = 0 integer, public :: line_num = 0 type( yaml_node ), public, pointer :: next => null() type( yaml_node ), public, pointer :: parent => null() character(len=:), public, allocatable :: value","tags":"","loc":"type/yaml_node.html"},{"title":"check_key_hierarchy – Fyaml","text":"public  function check_key_hierarchy(current, previous, target_indent) result(is_valid) Check key hierarchy for validity @param[in] current Current node to check\n@param[in] previous Previous node to compare with\n@param[in] target_indent Target indentation level\n@return True if the key hierarchy is valid Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(in), pointer :: current type( yaml_node ), intent(in), pointer :: previous integer, intent(in) :: target_indent Return Value logical Calls proc~~check_key_hierarchy~~CallsGraph proc~check_key_hierarchy check_key_hierarchy proc~debug_print debug_print proc~check_key_hierarchy->proc~debug_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), public :: debug_msg","tags":"","loc":"proc/check_key_hierarchy.html"},{"title":"check_sequence_node – Fyaml","text":"public  function check_sequence_node(node) result(is_seq) Check if value is a sequence @param[in] node Node to check\n@return True if the node represents a sequence Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(in), pointer :: node Return Value logical Called by proc~~check_sequence_node~~CalledByGraph proc~check_sequence_node check_sequence_node interface~check_sequence check_sequence interface~check_sequence->proc~check_sequence_node Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( yaml_node ), public, pointer :: current","tags":"","loc":"proc/check_sequence_node.html"},{"title":"count_leading_spaces – Fyaml","text":"public  function count_leading_spaces(line) Count leading spaces in a string Used for determining indentation level @param[in]  line Input string\n@return     Number of leading spaces Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer Called by proc~~count_leading_spaces~~CalledByGraph proc~count_leading_spaces count_leading_spaces proc~find_sequence_parent find_sequence_parent proc~find_sequence_parent->proc~count_leading_spaces proc~find_sequence_parent_node find_sequence_parent_node proc~find_sequence_parent_node->proc~count_leading_spaces proc~has_sequence_parent has_sequence_parent proc~has_sequence_parent->proc~count_leading_spaces proc~parse_line parse_line proc~parse_line->proc~count_leading_spaces proc~handle_block_sequence handle_block_sequence proc~handle_block_sequence->proc~find_sequence_parent_node proc~parse_yaml_wrapper parse_yaml_wrapper proc~parse_yaml_wrapper->proc~parse_line interface~parse_yaml parse_yaml interface~parse_yaml->proc~parse_yaml_wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/count_leading_spaces.html"},{"title":"find_block_sequence_parent – Fyaml","text":"public  function find_block_sequence_parent(root, item_node) result(parent) Find parent node for block sequence item @param[in] root Root node to start search from\n@param[in] item_node Node representing the sequence item\n@return Parent node found for the sequence item Arguments Type Intent Optional Attributes Name type( yaml_node ), pointer :: root type( yaml_node ), pointer :: item_node Return Value type( yaml_node ), pointer Calls proc~~find_block_sequence_parent~~CallsGraph proc~find_block_sequence_parent find_block_sequence_parent proc~debug_print debug_print proc~find_block_sequence_parent->proc~debug_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~find_block_sequence_parent~~CalledByGraph proc~find_block_sequence_parent find_block_sequence_parent proc~parse_line parse_line proc~parse_line->proc~find_block_sequence_parent proc~parse_yaml_wrapper parse_yaml_wrapper proc~parse_yaml_wrapper->proc~parse_line interface~parse_yaml parse_yaml interface~parse_yaml->proc~parse_yaml_wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: MAX_STACK = 100 integer, public :: alloc_stat type( yaml_node ), public, pointer :: best_candidate type( yaml_node ), public, pointer :: current integer, public :: current_indent character(len=256), public :: debug_msg logical, public :: found_match integer, public :: indent_level integer, public :: item_indent type( stack_entry ), public, allocatable :: stack (:) integer, public :: stack_top","tags":"","loc":"proc/find_block_sequence_parent.html"},{"title":"find_nested_node – Fyaml","text":"public recursive function find_nested_node(node, key_path) result(found_node) Find a nested node by key path @param[in] node Node to start search from\n@param[in] key_path Key path to search for, separated by '%'\n@return Found node matching the key path Arguments Type Intent Optional Attributes Name type( yaml_node ), pointer :: node character(len=*), intent(in) :: key_path Return Value type( yaml_node ), pointer Variables Type Visibility Attributes Name Initial type( yaml_node ), public, pointer :: current integer, public :: delim_pos character(len=:), public, allocatable :: first_key character(len=:), public, allocatable :: remaining_path","tags":"","loc":"proc/find_nested_node.html"},{"title":"find_or_create_intermediate_nodes – Fyaml","text":"public  function find_or_create_intermediate_nodes(parent, target_indent, new_node) result(last_node) Find or create intermediate nodes to match target indentation @param[inout] parent Parent node to start from\n@param[in] target_indent Target indentation level\n@param[in] new_node Node to link at target indentation\n@return Last node created or found at target indentation Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(inout), pointer :: parent integer, intent(in) :: target_indent type( yaml_node ), intent(in), pointer :: new_node Return Value type( yaml_node ), pointer Calls proc~~find_or_create_intermediate_nodes~~CallsGraph proc~find_or_create_intermediate_nodes find_or_create_intermediate_nodes proc~initialize_node initialize_node proc~find_or_create_intermediate_nodes->proc~initialize_node Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: current_indent type( yaml_node ), public, pointer :: current_node character(len=256), public :: debug_msg type( yaml_node ), public, pointer :: prev_node","tags":"","loc":"proc/find_or_create_intermediate_nodes.html"},{"title":"find_parent_by_indent – Fyaml","text":"public  function find_parent_by_indent(root, child_indent, line_num) result(parent) Find parent node by indentation level @param[in] root Root node to start search from\n@param[in] child_indent Indentation level of the child node\n@param[in] line_num Line number of the child node\n@return Parent node found at the given indentation level Arguments Type Intent Optional Attributes Name type( yaml_node ), pointer :: root integer, intent(in) :: child_indent integer, intent(in) :: line_num Return Value type( yaml_node ), pointer Calls proc~~find_parent_by_indent~~CallsGraph proc~find_parent_by_indent find_parent_by_indent proc~debug_print debug_print proc~find_parent_by_indent->proc~debug_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~find_parent_by_indent~~CalledByGraph proc~find_parent_by_indent find_parent_by_indent proc~parse_line parse_line proc~parse_line->proc~find_parent_by_indent proc~parse_yaml_wrapper parse_yaml_wrapper proc~parse_yaml_wrapper->proc~parse_line interface~parse_yaml parse_yaml interface~parse_yaml->proc~parse_yaml_wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( yaml_node ), public, pointer :: best_parent type( yaml_node ), public, pointer :: current character(len=256), public :: debug_msg logical, public :: is_root_level type( yaml_node ), public, pointer :: last_valid_parent type( yaml_node ), public, pointer :: latest_root integer, public :: max_stack_size type( stack_entry ), public, allocatable :: node_stack (:) integer, public :: parent_level_indent integer, public :: stack_top","tags":"","loc":"proc/find_parent_by_indent.html"},{"title":"find_sequence_parent_node – Fyaml","text":"public  function find_sequence_parent_node(root, current) result(parent) Find parent node containing key for sequence @param[in] root Root node to start search from\n@param[in] current Node representing the sequence item\n@return Parent node found for the sequence item Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(in), pointer :: root type( yaml_node ), intent(in), pointer :: current Return Value type( yaml_node ), pointer Calls proc~~find_sequence_parent_node~~CallsGraph proc~find_sequence_parent_node find_sequence_parent_node proc~count_leading_spaces count_leading_spaces proc~find_sequence_parent_node->proc~count_leading_spaces proc~debug_print debug_print proc~find_sequence_parent_node->proc~debug_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~find_sequence_parent_node~~CalledByGraph proc~find_sequence_parent_node find_sequence_parent_node proc~handle_block_sequence handle_block_sequence proc~handle_block_sequence->proc~find_sequence_parent_node Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: current_indent character(len=256), public :: debug_msg type( yaml_node ), public, pointer :: temp integer, public :: temp_indent","tags":"","loc":"proc/find_sequence_parent_node.html"},{"title":"get_sequence_as_strings – Fyaml","text":"public  function get_sequence_as_strings(node) result(items) Get sequence items as string array @param[in] node Node representing the sequence\n@return Array of sequence items as strings Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(in), pointer :: node Return Value character(len=:), allocatable, dimension(:) Calls proc~~get_sequence_as_strings~~CallsGraph proc~get_sequence_as_strings get_sequence_as_strings proc~debug_print debug_print proc~get_sequence_as_strings->proc~debug_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: clean_value integer, public :: count type( yaml_node ), public, pointer :: current character(len=256), public :: debug_msg integer, public :: i","tags":"","loc":"proc/get_sequence_as_strings.html"},{"title":"has_sequence_parent – Fyaml","text":"public  function has_sequence_parent(root, indent) result(has_parent) Check if node has a sequence parent at given indent @param[in] root Root node to start search from\n@param[in] indent Indentation level to check for parent\n@return True if a sequence parent is found at the given indent Arguments Type Intent Optional Attributes Name type( yaml_node ), pointer :: root integer, intent(in) :: indent Return Value logical Calls proc~~has_sequence_parent~~CallsGraph proc~has_sequence_parent has_sequence_parent proc~count_leading_spaces count_leading_spaces proc~has_sequence_parent->proc~count_leading_spaces Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( yaml_node ), public, pointer :: current","tags":"","loc":"proc/has_sequence_parent.html"},{"title":"integer_to_string – Fyaml","text":"public  function integer_to_string(num) result(str) Convert integer to string @param[in] num Integer to convert\n@return String representation of the integer Arguments Type Intent Optional Attributes Name integer, intent(in) :: num Return Value character(len=32) Called by proc~~integer_to_string~~CalledByGraph proc~integer_to_string integer_to_string proc~parse_line parse_line proc~parse_line->proc~integer_to_string proc~parse_yaml_wrapper parse_yaml_wrapper proc~parse_yaml_wrapper->proc~integer_to_string proc~parse_yaml_wrapper->proc~parse_line interface~parse_yaml parse_yaml interface~parse_yaml->proc~parse_yaml_wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/integer_to_string.html"},{"title":"starts_with_trimmed – Fyaml","text":"public  function starts_with_trimmed(line, prefix) Check if a trimmed line starts with a specific string @param[in] line   Input line\n@param[in] prefix Prefix string to check\n@return     True if the trimmed line starts with the prefix Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line character(len=*), intent(in) :: prefix Return Value logical Called by proc~~starts_with_trimmed~~CalledByGraph proc~starts_with_trimmed starts_with_trimmed proc~parse_yaml_wrapper parse_yaml_wrapper proc~parse_yaml_wrapper->proc~starts_with_trimmed interface~parse_yaml parse_yaml interface~parse_yaml->proc~parse_yaml_wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: trimmed_line","tags":"","loc":"proc/starts_with_trimmed.html"},{"title":"to_lower – Fyaml","text":"public  function to_lower(str) result(lower_str) Convert string to lowercase @param[in]  str Input string\n@return     Lowercase version of input Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len) Called by proc~~to_lower~~CalledByGraph proc~to_lower to_lower proc~determine_value_type determine_value_type proc~determine_value_type->proc~to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: i","tags":"","loc":"proc/to_lower.html"},{"title":"add_sequence_item – Fyaml","text":"public  subroutine add_sequence_item(parent, value) Add a new item to a sequence node @param[inout] parent Parent node representing the sequence\n@param[in] value Value of the new sequence item Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(inout), pointer :: parent character(len=*), intent(in) :: value Calls proc~~add_sequence_item~~CallsGraph proc~add_sequence_item add_sequence_item proc~initialize_node initialize_node proc~add_sequence_item->proc~initialize_node Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~add_sequence_item~~CalledByGraph proc~add_sequence_item add_sequence_item proc~parse_flow_form parse_flow_form proc~parse_flow_form->proc~add_sequence_item proc~parse_line parse_line proc~parse_line->proc~parse_flow_form proc~parse_yaml_wrapper parse_yaml_wrapper proc~parse_yaml_wrapper->proc~parse_line interface~parse_yaml parse_yaml interface~parse_yaml->proc~parse_yaml_wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: clean_value type( yaml_node ), public, pointer :: current type( yaml_node ), public, pointer :: new_item","tags":"","loc":"proc/add_sequence_item.html"},{"title":"cleanup_indent_history – Fyaml","text":"public  subroutine cleanup_indent_history() Clean up indent history when done parsing Arguments None Called by proc~~cleanup_indent_history~~CalledByGraph proc~cleanup_indent_history cleanup_indent_history proc~parse_yaml_wrapper parse_yaml_wrapper proc~parse_yaml_wrapper->proc~cleanup_indent_history interface~parse_yaml parse_yaml interface~parse_yaml->proc~parse_yaml_wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( indent_tracker ), public, pointer :: current type( indent_tracker ), public, pointer :: next","tags":"","loc":"proc/cleanup_indent_history.html"},{"title":"count_documents – Fyaml","text":"public  subroutine count_documents(filename, size_out, found_marker, stat) Helper subroutine to count the number of YAML documents in a file @param[in] filename Name of the YAML file to count documents in\n@param[out] size_out Number of documents found\n@param[out] found_marker Logical flag indicating if document markers were found\n@param[out] stat Status code indicating success or error Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer, intent(out) :: size_out logical, intent(out) :: found_marker integer, intent(out) :: stat Called by proc~~count_documents~~CalledByGraph proc~count_documents count_documents proc~parse_yaml_wrapper parse_yaml_wrapper proc~parse_yaml_wrapper->proc~count_documents interface~parse_yaml parse_yaml interface~parse_yaml->proc~parse_yaml_wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: io_stat character(len=1024), public :: line integer, public :: unit_num","tags":"","loc":"proc/count_documents.html"},{"title":"debug_print – Fyaml","text":"public  subroutine debug_print(level, message, error_code, msg_type) Print debug messages with appropriate formatting and prefixes @param[in] level Debug level of the message\n@param[in] message The debug message to print\n@param[in] error_code Optional error code associated with the message\n@param[in] msg_type Optional message type for prefix selection Arguments Type Intent Optional Attributes Name integer, intent(in) :: level character(len=*), intent(in) :: message integer, intent(in), optional :: error_code character(len=*), intent(in), optional :: msg_type Called by proc~~debug_print~~CalledByGraph proc~debug_print debug_print proc~check_key_hierarchy check_key_hierarchy proc~check_key_hierarchy->proc~debug_print proc~debug_print_node_structure debug_print_node_structure proc~debug_print_node_structure->proc~debug_print proc~debug_print_node_structure->proc~debug_print_node_structure proc~find_block_sequence_parent find_block_sequence_parent proc~find_block_sequence_parent->proc~debug_print proc~find_parent_by_indent find_parent_by_indent proc~find_parent_by_indent->proc~debug_print proc~find_sequence_parent_node find_sequence_parent_node proc~find_sequence_parent_node->proc~debug_print proc~get_sequence_as_strings get_sequence_as_strings proc~get_sequence_as_strings->proc~debug_print proc~parse_flow_form parse_flow_form proc~parse_flow_form->proc~debug_print proc~parse_line parse_line proc~parse_line->proc~debug_print proc~parse_line->proc~find_block_sequence_parent proc~parse_line->proc~find_parent_by_indent proc~parse_line->proc~parse_flow_form proc~parse_yaml_wrapper parse_yaml_wrapper proc~parse_yaml_wrapper->proc~debug_print proc~parse_yaml_wrapper->proc~parse_line proc~validate_node validate_node proc~validate_node->proc~debug_print interface~parse_yaml parse_yaml interface~parse_yaml->proc~parse_yaml_wrapper proc~handle_block_sequence handle_block_sequence proc~handle_block_sequence->proc~find_sequence_parent_node Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: formatted_msg character(len=:), public, allocatable :: prefix","tags":"","loc":"proc/debug_print.html"},{"title":"debug_print_node_structure – Fyaml","text":"public recursive subroutine debug_print_node_structure(node, prefix, max_depth) Print the structure of a YAML node and its children for debugging @param[in] node Node to print\n@param[in] prefix Prefix string for indentation\n@param[in] max_depth Optional maximum depth to print Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(in), pointer :: node character(len=*), intent(in) :: prefix integer, intent(in), optional :: max_depth Calls proc~~debug_print_node_structure~~CallsGraph proc~debug_print_node_structure debug_print_node_structure proc~debug_print_node_structure->proc~debug_print_node_structure proc~debug_print debug_print proc~debug_print_node_structure->proc~debug_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( yaml_node ), public, pointer :: current integer, public :: current_depth character(len=256), public :: debug_msg","tags":"","loc":"proc/debug_print_node_structure.html"},{"title":"determine_value_type – Fyaml","text":"public  subroutine determine_value_type(node) Determine value type of node Checks content and sets appropriate type flags @param[in,out] node Node to analyze Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(inout) :: node Calls proc~~determine_value_type~~CallsGraph proc~determine_value_type determine_value_type proc~to_lower to_lower proc~determine_value_type->proc~to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: i_value logical, public :: is_int logical, public :: is_real logical, public :: l_value real, public :: r_value integer, public :: rc character(len=32), public :: temp_str","tags":"","loc":"proc/determine_value_type.html"},{"title":"find_sequence_parent – Fyaml","text":"public  subroutine find_sequence_parent(root, indent, parent_key) Find the parent key for a sequence @param[in] root Root node to start search from\n@param[in] indent Indentation level to search for parent key\n@param[out] parent_key Key of the parent node found Arguments Type Intent Optional Attributes Name type( yaml_node ), pointer :: root integer, intent(in) :: indent character(len=:), intent(out), allocatable :: parent_key Calls proc~~find_sequence_parent~~CallsGraph proc~find_sequence_parent find_sequence_parent proc~count_leading_spaces count_leading_spaces proc~find_sequence_parent->proc~count_leading_spaces Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( yaml_node ), public, pointer :: current integer, public :: current_indent","tags":"","loc":"proc/find_sequence_parent.html"},{"title":"handle_block_sequence – Fyaml","text":"public  subroutine handle_block_sequence(line, doc, node, status) Handle block sequence items, ensuring they're properly linked and labeled @param[in] line Input line containing sequence item\n@param[inout] doc Document being built\n@param[inout] node Node representing the sequence item\n@param[out] status Status code indicating success or error Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line type( yaml_document ), intent(inout) :: doc type( yaml_node ), intent(inout), pointer :: node integer, intent(out) :: status Calls proc~~handle_block_sequence~~CallsGraph proc~handle_block_sequence handle_block_sequence proc~find_sequence_parent_node find_sequence_parent_node proc~handle_block_sequence->proc~find_sequence_parent_node proc~count_leading_spaces count_leading_spaces proc~find_sequence_parent_node->proc~count_leading_spaces proc~debug_print debug_print proc~find_sequence_parent_node->proc~debug_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( yaml_node ), public, pointer :: parent","tags":"","loc":"proc/handle_block_sequence.html"},{"title":"initialize_document – Fyaml","text":"public  subroutine initialize_document(doc) Initialize a new YAML document Sets up empty document structure with nullified root @param[in,out] doc Document to initialize Arguments Type Intent Optional Attributes Name type( yaml_document ), intent(inout) :: doc Called by proc~~initialize_document~~CalledByGraph proc~initialize_document initialize_document proc~parse_yaml_wrapper parse_yaml_wrapper proc~parse_yaml_wrapper->proc~initialize_document interface~parse_yaml parse_yaml interface~parse_yaml->proc~parse_yaml_wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/initialize_document.html"},{"title":"initialize_node – Fyaml","text":"public  subroutine initialize_node(node) Initialize a new YAML node Sets default values for a newly created node @param[in,out] node Node to initialize Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(inout), pointer :: node Called by proc~~initialize_node~~CalledByGraph proc~initialize_node initialize_node proc~add_sequence_item add_sequence_item proc~add_sequence_item->proc~initialize_node proc~find_or_create_intermediate_nodes find_or_create_intermediate_nodes proc~find_or_create_intermediate_nodes->proc~initialize_node proc~parse_line parse_line proc~parse_line->proc~initialize_node proc~parse_flow_form parse_flow_form proc~parse_line->proc~parse_flow_form proc~parse_mapping parse_mapping proc~parse_mapping->proc~initialize_node proc~parse_flow_form->proc~add_sequence_item proc~parse_yaml_wrapper parse_yaml_wrapper proc~parse_yaml_wrapper->proc~parse_line interface~parse_yaml parse_yaml interface~parse_yaml->proc~parse_yaml_wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/initialize_node.html"},{"title":"parse_flow_form – Fyaml","text":"public  subroutine parse_flow_form(line, node) Parse flow-style YAML syntax Handles flow-style sequences [...] and mappings {...} @param[in] line Input containing flow syntax\n@param[inout] node Node to store parsed content Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line type( yaml_node ), intent(inout), pointer :: node Calls proc~~parse_flow_form~~CallsGraph proc~parse_flow_form parse_flow_form proc~add_sequence_item add_sequence_item proc~parse_flow_form->proc~add_sequence_item proc~debug_print debug_print proc~parse_flow_form->proc~debug_print proc~initialize_node initialize_node proc~add_sequence_item->proc~initialize_node Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_flow_form~~CalledByGraph proc~parse_flow_form parse_flow_form proc~parse_line parse_line proc~parse_line->proc~parse_flow_form proc~parse_yaml_wrapper parse_yaml_wrapper proc~parse_yaml_wrapper->proc~parse_line interface~parse_yaml parse_yaml interface~parse_yaml->proc~parse_yaml_wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: content type( yaml_node ), public, pointer :: current_item integer, public :: end logical, public :: in_bracket logical, public :: in_quotes character(len=:), public, allocatable :: item integer, public :: item_end integer, public :: item_start integer, public :: pos type( yaml_node ), public, pointer :: prev_item integer, public :: start","tags":"","loc":"proc/parse_flow_form.html"},{"title":"parse_line – Fyaml","text":"public  subroutine parse_line(line, doc, status, line_num) Parse a single line of YAML content Processes a line and updates document structure. Handles:\n- Indentation\n- Sequence items\n- Key-value pairs\n- Nested structures @param[in]     line Input line\n@param[in,out] doc  Document being built\n@param[out]    status Status code\n@param[in]     line_num Line number of the input line Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line type( yaml_document ), intent(inout) :: doc integer, intent(out) :: status integer, intent(in) :: line_num Calls proc~~parse_line~~CallsGraph proc~parse_line parse_line proc~count_leading_spaces count_leading_spaces proc~parse_line->proc~count_leading_spaces proc~debug_print debug_print proc~parse_line->proc~debug_print proc~find_block_sequence_parent find_block_sequence_parent proc~parse_line->proc~find_block_sequence_parent proc~find_parent_by_indent find_parent_by_indent proc~parse_line->proc~find_parent_by_indent proc~initialize_node initialize_node proc~parse_line->proc~initialize_node proc~integer_to_string integer_to_string proc~parse_line->proc~integer_to_string proc~parse_flow_form parse_flow_form proc~parse_line->proc~parse_flow_form proc~record_indent_level record_indent_level proc~parse_line->proc~record_indent_level proc~find_block_sequence_parent->proc~debug_print proc~find_parent_by_indent->proc~debug_print proc~parse_flow_form->proc~debug_print proc~add_sequence_item add_sequence_item proc~parse_flow_form->proc~add_sequence_item proc~add_sequence_item->proc~initialize_node Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_line~~CalledByGraph proc~parse_line parse_line proc~parse_yaml_wrapper parse_yaml_wrapper proc~parse_yaml_wrapper->proc~parse_line interface~parse_yaml parse_yaml interface~parse_yaml->proc~parse_yaml_wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: current_indent type( yaml_node ), public, pointer :: current_node character(len=256), public :: debug_msg character(len=256), public :: error_msg integer, public :: io_stat logical, public :: is_sequence_item character(len=:), public, allocatable :: local_line type( yaml_node ), public, pointer :: new_node integer, public :: parent_indent character(len=:), public, allocatable :: parent_key type( yaml_node ), public, pointer :: parent_node integer, public :: pos","tags":"","loc":"proc/parse_line.html"},{"title":"parse_mapping – Fyaml","text":"public  subroutine parse_mapping(content, node) Parse mapping elements from flow style Splits comma-separated key-value pairs into nodes @param[inout] content Mapping content string\n@param[inout] node Node to store mapping Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: content type( yaml_node ), intent(inout), pointer :: node Calls proc~~parse_mapping~~CallsGraph proc~parse_mapping parse_mapping proc~initialize_node initialize_node proc~parse_mapping->proc~initialize_node Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: content_len character(len=:), public, allocatable :: key character(len=:), public, allocatable :: local_content character(len=:), public, allocatable :: pair integer, public :: pos character(len=:), public, allocatable :: value","tags":"","loc":"proc/parse_mapping.html"},{"title":"parse_yaml_wrapper – Fyaml","text":"public  subroutine parse_yaml_wrapper(filename, docs, status) Wrapper subroutine for parsing YAML files @param[in] filename Name of the YAML file to parse\n@param[out] docs Array of parsed YAML documents\n@param[out] status Status code indicating success or error Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( yaml_document ), intent(out), allocatable :: docs (:) integer, intent(out) :: status Calls proc~~parse_yaml_wrapper~~CallsGraph proc~parse_yaml_wrapper parse_yaml_wrapper proc~cleanup_indent_history cleanup_indent_history proc~parse_yaml_wrapper->proc~cleanup_indent_history proc~count_documents count_documents proc~parse_yaml_wrapper->proc~count_documents proc~debug_print debug_print proc~parse_yaml_wrapper->proc~debug_print proc~initialize_document initialize_document proc~parse_yaml_wrapper->proc~initialize_document proc~integer_to_string integer_to_string proc~parse_yaml_wrapper->proc~integer_to_string proc~parse_line parse_line proc~parse_yaml_wrapper->proc~parse_line proc~starts_with_trimmed starts_with_trimmed proc~parse_yaml_wrapper->proc~starts_with_trimmed proc~parse_line->proc~debug_print proc~parse_line->proc~integer_to_string proc~count_leading_spaces count_leading_spaces proc~parse_line->proc~count_leading_spaces proc~find_block_sequence_parent find_block_sequence_parent proc~parse_line->proc~find_block_sequence_parent proc~find_parent_by_indent find_parent_by_indent proc~parse_line->proc~find_parent_by_indent proc~initialize_node initialize_node proc~parse_line->proc~initialize_node proc~parse_flow_form parse_flow_form proc~parse_line->proc~parse_flow_form proc~record_indent_level record_indent_level proc~parse_line->proc~record_indent_level proc~find_block_sequence_parent->proc~debug_print proc~find_parent_by_indent->proc~debug_print proc~parse_flow_form->proc~debug_print proc~add_sequence_item add_sequence_item proc~parse_flow_form->proc~add_sequence_item proc~add_sequence_item->proc~initialize_node Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_yaml_wrapper~~CalledByGraph proc~parse_yaml_wrapper parse_yaml_wrapper interface~parse_yaml parse_yaml interface~parse_yaml->proc~parse_yaml_wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public :: doc_count logical, public :: found_doc_marker","tags":"","loc":"proc/parse_yaml_wrapper.html"},{"title":"record_indent_level – Fyaml","text":"public  subroutine record_indent_level(indent, key, line_num) Record the last key at a given indentation level @param[in] indent Indentation level\n@param[in] key Key to record\n@param[in] line_num Line number of the key Arguments Type Intent Optional Attributes Name integer, intent(in) :: indent character(len=*), intent(in) :: key integer, intent(in) :: line_num Called by proc~~record_indent_level~~CalledByGraph proc~record_indent_level record_indent_level proc~parse_line parse_line proc~parse_line->proc~record_indent_level proc~parse_yaml_wrapper parse_yaml_wrapper proc~parse_yaml_wrapper->proc~parse_line interface~parse_yaml parse_yaml interface~parse_yaml->proc~parse_yaml_wrapper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( indent_tracker ), public, pointer :: current type( indent_tracker ), public, pointer :: new_entry","tags":"","loc":"proc/record_indent_level.html"},{"title":"set_debug_level – Fyaml","text":"public  subroutine set_debug_level(level) Set the debug output level for the YAML parser @param[in] level Debug level (DEBUG_ERROR or DEBUG_INFO) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level","tags":"","loc":"proc/set_debug_level.html"},{"title":"validate_node – Fyaml","text":"public  subroutine validate_node(node, status) Validate node structure and contents Performs validation checks on node pointers and content @param[in] node Node to validate\n@param[out] status Status code (ERR_SUCCESS if valid) Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(in), pointer :: node integer, intent(out) :: status Calls proc~~validate_node~~CallsGraph proc~validate_node validate_node proc~debug_print debug_print proc~validate_node->proc~debug_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/validate_node.html"},{"title":"check_sequence – Fyaml","text":"public interface check_sequence Calls interface~~check_sequence~~CallsGraph interface~check_sequence check_sequence proc~check_sequence_node check_sequence_node interface~check_sequence->proc~check_sequence_node Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function check_sequence_node (node) result(is_seq) Check if value is a sequence Read more… Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(in), pointer :: node Return Value logical","tags":"","loc":"interface/check_sequence.html"},{"title":"parse_yaml – Fyaml","text":"public interface parse_yaml Calls interface~~parse_yaml~~CallsGraph interface~parse_yaml parse_yaml proc~parse_yaml_wrapper parse_yaml_wrapper interface~parse_yaml->proc~parse_yaml_wrapper proc~cleanup_indent_history cleanup_indent_history proc~parse_yaml_wrapper->proc~cleanup_indent_history proc~count_documents count_documents proc~parse_yaml_wrapper->proc~count_documents proc~debug_print debug_print proc~parse_yaml_wrapper->proc~debug_print proc~initialize_document initialize_document proc~parse_yaml_wrapper->proc~initialize_document proc~integer_to_string integer_to_string proc~parse_yaml_wrapper->proc~integer_to_string proc~parse_line parse_line proc~parse_yaml_wrapper->proc~parse_line proc~starts_with_trimmed starts_with_trimmed proc~parse_yaml_wrapper->proc~starts_with_trimmed proc~parse_line->proc~debug_print proc~parse_line->proc~integer_to_string proc~count_leading_spaces count_leading_spaces proc~parse_line->proc~count_leading_spaces proc~find_block_sequence_parent find_block_sequence_parent proc~parse_line->proc~find_block_sequence_parent proc~find_parent_by_indent find_parent_by_indent proc~parse_line->proc~find_parent_by_indent proc~initialize_node initialize_node proc~parse_line->proc~initialize_node proc~parse_flow_form parse_flow_form proc~parse_line->proc~parse_flow_form proc~record_indent_level record_indent_level proc~parse_line->proc~record_indent_level proc~find_block_sequence_parent->proc~debug_print proc~find_parent_by_indent->proc~debug_print proc~parse_flow_form->proc~debug_print proc~add_sequence_item add_sequence_item proc~parse_flow_form->proc~add_sequence_item proc~add_sequence_item->proc~initialize_node Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine parse_yaml_wrapper (filename, docs, status) Wrapper subroutine for parsing YAML files Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( yaml_document ), intent(out), allocatable :: docs (:) integer, intent(out) :: status","tags":"","loc":"interface/parse_yaml.html"},{"title":"get_root_keys – Fyaml","text":"public  function get_root_keys(this) result(keys) Get all root keys from the document @param[in] this Document instance\n@return Array of root key names Type Bound fyaml_doc Arguments Type Intent Optional Attributes Name class( fyaml_doc ), intent(in) :: this Return Value character(len=:), allocatable, dimension(:)","tags":"","loc":"proc/get_root_keys.html"},{"title":"split_key – Fyaml","text":"public  function split_key(path) result(parts) Split a path by % delimiter @param[in] path Path string to split\n@return Array of path segments Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=:), allocatable, dimension(:)","tags":"","loc":"proc/split_key.html"},{"title":"count_children – Fyaml","text":"public interface count_children Module Procedures private  function count_node_children(node) result(count) Count direct children of a yaml_node @param[in] node Node to count children for\n@return Number of direct children Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(in), pointer :: node Return Value integer private  function count_value_children(val) result(count) Count direct children of a yaml_value @param[in] val Value to count children for\n@return Number of direct children Arguments Type Intent Optional Attributes Name type( yaml_value ), intent(in) :: val Return Value integer","tags":"","loc":"interface/count_children.html"},{"title":"get_child_keys – Fyaml","text":"public interface get_child_keys Module Procedures private  function get_node_child_keys(node) result(keys) Get all child keys of a yaml_node @param[in] node Node to get children from\n@return Array of child key names Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(in), pointer :: node Return Value character(len=:), allocatable, dimension(:) private  function get_value_child_keys(val) result(keys) Get all child keys of a yaml_value @param[in] val Value to get children from\n@return Array of child key names Arguments Type Intent Optional Attributes Name class( yaml_value ), intent(in) :: val Return Value character(len=:), allocatable, dimension(:)","tags":"","loc":"interface/get_child_keys.html"},{"title":"yaml_parser – Fyaml","text":"YAML Parser module This module provides functionality for parsing YAML files into Fortran data structures.\nIt handles document structure, value types, indentation, sequences, and mapping nodes. Note Supports basic YAML features including scalars, sequences, and mappings\n@author Barry Baker\n@version 0.1.0\n@see yaml_types\n@see fyaml Uses yaml_types iso_fortran_env module~~yaml_parser~~UsesGraph module~yaml_parser yaml_parser iso_fortran_env iso_fortran_env module~yaml_parser->iso_fortran_env module~yaml_types yaml_types module~yaml_parser->module~yaml_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~yaml_parser~~UsedByGraph module~yaml_parser yaml_parser module~fyaml fyaml module~fyaml->module~yaml_parser Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: DBG_CHILD = \"  |- CHILD: \" character(len=*), public, parameter :: DBG_FMT_INDENT = \"(2A)\" character(len=*), public, parameter :: DBG_FMT_KEY = \"(2A)\" character(len=*), public, parameter :: DBG_FMT_LEVEL = \"(A,I0,2A,I0)\" character(len=*), public, parameter :: DBG_FMT_NODE = \"(3A,I0)\" character(len=*), public, parameter :: DBG_INDENT = \"    \" character(len=*), public, parameter :: DBG_LEVEL = \"LEVEL \" character(len=*), public, parameter :: DBG_NEW_NODE = \"--- NEW NODE: \" character(len=*), public, parameter :: DBG_PARENT = \"=== PARENT: \" character(len=*), public, parameter :: DBG_SIBLING = \"  |+ SIBLING: \" integer, public, parameter :: DEBUG_ERROR = 1 Show only error messages integer, public, parameter :: DEBUG_INFO = 2 Show general info messages integer, public, parameter :: ERR_FILE = 1 File access error integer, public, parameter :: ERR_MEMORY = 3 Memory allocation error integer, public, parameter :: ERR_PARSE = 2 Parse error integer, public, parameter :: ERR_SUCCESS = 0 Operation completed successfully integer, public :: debug_level = DEBUG_INFO type( indent_tracker ), public, pointer, save :: indent_history => null() integer, public :: indent_width = 2 Interfaces public        interface check_sequence public  function check_sequence_node (node) result(is_seq) Check if value is a sequence @param[in] node Node to check\n@return True if the node represents a sequence Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(in), pointer :: node Return Value logical public        interface parse_yaml public  subroutine parse_yaml_wrapper (filename, docs, status) Wrapper subroutine for parsing YAML files @param[in] filename Name of the YAML file to parse\n@param[out] docs Array of parsed YAML documents\n@param[out] status Status code indicating success or error Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( yaml_document ), intent(out), allocatable :: docs (:) integer, intent(out) :: status Derived Types type, public :: indent_tracker Components Type Visibility Attributes Name Initial integer, public :: indent character(len=:), public, allocatable :: last_key integer, public :: line_num type( indent_tracker ), public, pointer :: next => null() type, public :: stack_entry Components Type Visibility Attributes Name Initial type( yaml_node ), public, pointer :: node => null() Functions public  function check_key_hierarchy (current, previous, target_indent) result(is_valid) Check key hierarchy for validity Read more… Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(in), pointer :: current type( yaml_node ), intent(in), pointer :: previous integer, intent(in) :: target_indent Return Value logical public  function check_sequence_node (node) result(is_seq) Check if value is a sequence Read more… Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(in), pointer :: node Return Value logical public  function count_leading_spaces (line) Count leading spaces in a string Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer public  function find_block_sequence_parent (root, item_node) result(parent) Find parent node for block sequence item Read more… Arguments Type Intent Optional Attributes Name type( yaml_node ), pointer :: root type( yaml_node ), pointer :: item_node Return Value type( yaml_node ), pointer public recursive function find_nested_node (node, key_path) result(found_node) Find a nested node by key path Read more… Arguments Type Intent Optional Attributes Name type( yaml_node ), pointer :: node character(len=*), intent(in) :: key_path Return Value type( yaml_node ), pointer public  function find_or_create_intermediate_nodes (parent, target_indent, new_node) result(last_node) Find or create intermediate nodes to match target indentation Read more… Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(inout), pointer :: parent integer, intent(in) :: target_indent type( yaml_node ), intent(in), pointer :: new_node Return Value type( yaml_node ), pointer public  function find_parent_by_indent (root, child_indent, line_num) result(parent) Find parent node by indentation level Read more… Arguments Type Intent Optional Attributes Name type( yaml_node ), pointer :: root integer, intent(in) :: child_indent integer, intent(in) :: line_num Return Value type( yaml_node ), pointer public  function find_sequence_parent_node (root, current) result(parent) Find parent node containing key for sequence Read more… Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(in), pointer :: root type( yaml_node ), intent(in), pointer :: current Return Value type( yaml_node ), pointer public  function get_sequence_as_strings (node) result(items) Get sequence items as string array Read more… Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(in), pointer :: node Return Value character(len=:), allocatable, dimension(:) public  function has_sequence_parent (root, indent) result(has_parent) Check if node has a sequence parent at given indent Read more… Arguments Type Intent Optional Attributes Name type( yaml_node ), pointer :: root integer, intent(in) :: indent Return Value logical public  function integer_to_string (num) result(str) Convert integer to string Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: num Return Value character(len=32) public  function starts_with_trimmed (line, prefix) Check if a trimmed line starts with a specific string Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line character(len=*), intent(in) :: prefix Return Value logical public  function to_lower (str) result(lower_str) Convert string to lowercase Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len) Subroutines public  subroutine add_sequence_item (parent, value) Add a new item to a sequence node Read more… Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(inout), pointer :: parent character(len=*), intent(in) :: value public  subroutine cleanup_indent_history () Clean up indent history when done parsing Arguments None public  subroutine count_documents (filename, size_out, found_marker, stat) Helper subroutine to count the number of YAML documents in a file Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer, intent(out) :: size_out logical, intent(out) :: found_marker integer, intent(out) :: stat public  subroutine debug_print (level, message, error_code, msg_type) Print debug messages with appropriate formatting and prefixes Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: level character(len=*), intent(in) :: message integer, intent(in), optional :: error_code character(len=*), intent(in), optional :: msg_type public recursive subroutine debug_print_node_structure (node, prefix, max_depth) Print the structure of a YAML node and its children for debugging Read more… Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(in), pointer :: node character(len=*), intent(in) :: prefix integer, intent(in), optional :: max_depth public  subroutine determine_value_type (node) Determine value type of node Read more… Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(inout) :: node public  subroutine find_sequence_parent (root, indent, parent_key) Find the parent key for a sequence Read more… Arguments Type Intent Optional Attributes Name type( yaml_node ), pointer :: root integer, intent(in) :: indent character(len=:), intent(out), allocatable :: parent_key public  subroutine handle_block_sequence (line, doc, node, status) Handle block sequence items, ensuring they're properly linked and labeled Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line type( yaml_document ), intent(inout) :: doc type( yaml_node ), intent(inout), pointer :: node integer, intent(out) :: status public  subroutine initialize_document (doc) Initialize a new YAML document Read more… Arguments Type Intent Optional Attributes Name type( yaml_document ), intent(inout) :: doc public  subroutine initialize_node (node) Initialize a new YAML node Read more… Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(inout), pointer :: node public  subroutine parse_flow_form (line, node) Parse flow-style YAML syntax Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line type( yaml_node ), intent(inout), pointer :: node public  subroutine parse_line (line, doc, status, line_num) Parse a single line of YAML content Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line type( yaml_document ), intent(inout) :: doc integer, intent(out) :: status integer, intent(in) :: line_num public  subroutine parse_mapping (content, node) Parse mapping elements from flow style Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: content type( yaml_node ), intent(inout), pointer :: node public  subroutine parse_yaml_wrapper (filename, docs, status) Wrapper subroutine for parsing YAML files Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( yaml_document ), intent(out), allocatable :: docs (:) integer, intent(out) :: status public  subroutine record_indent_level (indent, key, line_num) Record the last key at a given indentation level Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: indent character(len=*), intent(in) :: key integer, intent(in) :: line_num public  subroutine set_debug_level (level) Set the debug output level for the YAML parser Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: level public  subroutine validate_node (node, status) Validate node structure and contents Read more… Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(in), pointer :: node integer, intent(out) :: status","tags":"","loc":"module/yaml_parser.html"},{"title":"fyaml – Fyaml","text":"A modern Fortran module for parsing YAML files This module provides functionality to read and parse YAML files into Fortran\ndata structures. It supports nested dictionaries, sequences, and various data types. Example: type ( fyaml_doc ) :: doc call doc % load ( \"config.yaml\" ) value = doc % get ( \"config%nested%key\" ) Note Supports strings, integers, reals, booleans, nulls, and sequences\n@version 1.0.0\n@see yaml_parser\n@see yaml_types Uses yaml_types iso_fortran_env yaml_parser module~~fyaml~~UsesGraph module~fyaml fyaml iso_fortran_env iso_fortran_env module~fyaml->iso_fortran_env module~yaml_parser yaml_parser module~fyaml->module~yaml_parser module~yaml_types yaml_types module~fyaml->module~yaml_types module~yaml_parser->iso_fortran_env module~yaml_parser->module~yaml_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface count_children private  function count_node_children(node) result(count) Count direct children of a yaml_node @param[in] node Node to count children for\n@return Number of direct children Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(in), pointer :: node Return Value integer private  function count_value_children(val) result(count) Count direct children of a yaml_value @param[in] val Value to count children for\n@return Number of direct children Arguments Type Intent Optional Attributes Name type( yaml_value ), intent(in) :: val Return Value integer public        interface get_child_keys private  function get_node_child_keys(node) result(keys) Get all child keys of a yaml_node @param[in] node Node to get children from\n@return Array of child key names Arguments Type Intent Optional Attributes Name type( yaml_node ), intent(in), pointer :: node Return Value character(len=:), allocatable, dimension(:) private  function get_value_child_keys(val) result(keys) Get all child keys of a yaml_value @param[in] val Value to get children from\n@return Array of child key names Arguments Type Intent Optional Attributes Name class( yaml_value ), intent(in) :: val Return Value character(len=:), allocatable, dimension(:) Derived Types type, public :: fyaml_doc Main document type for YAML parsing Read more… Components Type Visibility Attributes Name Initial type( yaml_dict ), public, allocatable :: docs (:) integer, public :: n_docs = 0 Type-Bound Procedures procedure, public :: get => get_doc_nested procedure, public :: get_bool => get_nested_bool procedure, public :: get_default_doc procedure, public :: get_doc => get_document procedure, public :: get_int => get_nested_int procedure, public :: get_real => get_nested_real procedure, public :: get_str => get_nested_str procedure, public :: load => load_yaml_doc procedure, public :: root_keys => get_root_keys type, public :: yaml_dict Dictionary container type Read more… Components Type Visibility Attributes Name Initial integer, public :: count = 0 type( yaml_pair ), public, pointer :: first => null() Type-Bound Procedures procedure, public :: get => get_value procedure, public :: keys => get_keys procedure, public :: set => set_value type, public :: yaml_pair Dictionary key-value pair type Read more… Components Type Visibility Attributes Name Initial integer, public :: indent_level = 0 character(len=:), public, allocatable :: key type( yaml_dict ), public, pointer :: nested => null() type( yaml_pair ), public, pointer :: next => null() type( yaml_value ), public :: value type, public :: yaml_value Value container type supporting multiple YAML data types Read more… Components Type Visibility Attributes Name Initial type( yaml_node ), public, pointer :: node => null() Type-Bound Procedures procedure, public :: child_at => get_child_at_index procedure, public :: child_keys => get_value_child_keys procedure, public :: get => get_value_nested procedure, public :: get_bool => get_boolean_value procedure, public :: get_int => get_integer_value procedure, public :: get_real => get_real_value procedure, public :: get_sequence => get_sequence_values procedure, public :: get_sequence_bool => get_sequence_bools procedure, public :: get_sequence_int => get_sequence_integers procedure, public :: get_sequence_real => get_sequence_reals procedure, public :: get_str => get_string_value procedure, public :: is_null => check_null procedure, public :: is_sequence => check_sequence_impl procedure, public :: size => get_sequence_size Functions public  function get_root_keys (this) result(keys) Get all root keys from the document Read more… Arguments Type Intent Optional Attributes Name class( fyaml_doc ), intent(in) :: this Return Value character(len=:), allocatable, dimension(:) public  function split_key (path) result(parts) Split a path by % delimiter Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=:), allocatable, dimension(:)","tags":"","loc":"module/fyaml.html"},{"title":"yaml_types – Fyaml","text":"Core YAML type definitions Defines the fundamental types needed for YAML parsing.\nThese types form the backbone of the document structure. @private Used by module~~yaml_types~~UsedByGraph module~yaml_types yaml_types module~fyaml fyaml module~fyaml->module~yaml_types module~yaml_parser yaml_parser module~fyaml->module~yaml_parser module~yaml_parser->module~yaml_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: yaml_document Document container type Components Type Visibility Attributes Name Initial type( yaml_node ), public, pointer :: root => null() type, public :: yaml_node Core node type for YAML elements Components Type Visibility Attributes Name Initial type( yaml_node ), public, pointer :: children => null() integer, public :: indent = 0 logical, public :: is_boolean = .false. logical, public :: is_float = .false. logical, public :: is_integer = .false. logical, public :: is_null = .false. logical, public :: is_root = .false. logical, public :: is_sequence = .false. logical, public :: is_string = .true. character(len=:), public, allocatable :: key integer, public :: last_child_line = 0 integer, public :: line_num = 0 type( yaml_node ), public, pointer :: next => null() type( yaml_node ), public, pointer :: parent => null() character(len=:), public, allocatable :: value","tags":"","loc":"module/yaml_types.html"},{"title":"yaml_parser.F90 – Fyaml","text":"This file depends on sourcefile~~yaml_parser.f90~~EfferentGraph sourcefile~yaml_parser.f90 yaml_parser.F90 sourcefile~yaml_types.f90 yaml_types.F90 sourcefile~yaml_parser.f90->sourcefile~yaml_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~yaml_parser.f90~~AfferentGraph sourcefile~yaml_parser.f90 yaml_parser.F90 sourcefile~fyaml.f90 fyaml.F90 sourcefile~fyaml.f90->sourcefile~yaml_parser.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> YAML Parser module !! !! This module provides functionality for parsing YAML files into Fortran data structures. !! It handles document structure, value types, indentation, sequences, and mapping nodes. !! !! @note Supports basic YAML features including scalars, sequences, and mappings !! @author Barry Baker !! @version 0.1.0 !! @see yaml_types !! @see fyaml module yaml_parser use yaml_types use iso_fortran_env , only : error_unit , output_unit implicit none ! Debug levels !============= !> Show only error messages integer , parameter :: DEBUG_ERROR = 1 !> Show general info messages integer , parameter :: DEBUG_INFO = 2 ! Error codes !============ !> Operation completed successfully integer , parameter :: ERR_SUCCESS = 0 !> File access error integer , parameter :: ERR_FILE = 1 !> Parse error integer , parameter :: ERR_PARSE = 2 !> Memory allocation error integer , parameter :: ERR_MEMORY = 3 ! Module variables !================= integer :: debug_level = DEBUG_INFO integer :: indent_width = 2 ! Default indentation width ! Public interfaces public :: find_sequence_parent_node , to_lower , count_leading_spaces public :: check_sequence , parse_yaml public :: find_nested_node ! Add this function to the public interface at the top of the module ! Private interfaces private :: is_real_string private :: is_int_string private :: is_block_sequence private :: find_last_sequence_item private :: find_last_nonsequence_node private :: parse_yaml_internal private :: set_indent_width private :: detect_indent_width ! Move check_sequence interface declaration here interface check_sequence module procedure check_sequence_node end interface ! Update interface for parse_yaml interface parse_yaml module procedure parse_yaml_wrapper end interface ! Add type definition at module level before contains type :: stack_entry type ( yaml_node ), pointer :: node => null () end type stack_entry ! Add constants for debug output formatting character ( len =* ), parameter :: DBG_NEW_NODE = \"--- NEW NODE: \" character ( len =* ), parameter :: DBG_PARENT = \"=== PARENT: \" character ( len =* ), parameter :: DBG_CHILD = \"  |- CHILD: \" character ( len =* ), parameter :: DBG_SIBLING = \"  |+ SIBLING: \" character ( len =* ), parameter :: DBG_LEVEL = \"LEVEL \" character ( len =* ), parameter :: DBG_INDENT = \"    \" ! Add new format specifiers for debug messages character ( len =* ), parameter :: DBG_FMT_INDENT = \"(2A)\" ! Changed from \"(A,I0)\" character ( len =* ), parameter :: DBG_FMT_NODE = \"(3A,I0)\" ! Changed from \"(A,A,A,I0)\" character ( len =* ), parameter :: DBG_FMT_KEY = \"(2A)\" ! No change needed character ( len =* ), parameter :: DBG_FMT_LEVEL = \"(A,I0,2A,I0)\" ! Changed from \"(2A,I0,2A)\" ! Add tracking for last key at each indent level type :: indent_tracker integer :: indent character ( len = :), allocatable :: last_key integer :: line_num type ( indent_tracker ), pointer :: next => null () end type indent_tracker ! Add module variable to track indentation history type ( indent_tracker ), pointer , save :: indent_history => null () contains !> Set the debug output level for the YAML parser !! !! @param[in] level Debug level (DEBUG_ERROR or DEBUG_INFO) subroutine set_debug_level ( level ) integer , intent ( in ) :: level debug_level = level end subroutine !> Set the indentation width used for parsing YAML structure !! !! @param[in] width Number of spaces per indentation level subroutine set_indent_width ( width ) integer , intent ( in ) :: width if ( width > 0 ) indent_width = width end subroutine !> Print debug messages with appropriate formatting and prefixes !! !! @param[in] level Debug level of the message !! @param[in] message The debug message to print !! @param[in] error_code Optional error code associated with the message !! @param[in] msg_type Optional message type for prefix selection subroutine debug_print ( level , message , error_code , msg_type ) integer , intent ( in ) :: level character ( len =* ), intent ( in ) :: message integer , intent ( in ), optional :: error_code character ( len =* ), intent ( in ), optional :: msg_type character ( len = :), allocatable :: prefix , formatted_msg if ( level <= debug_level ) then ! Determine prefix based on message type if ( present ( msg_type )) then select case ( msg_type ) case ( \"NEW_NODE\" ) prefix = DBG_NEW_NODE case ( \"PARENT\" ) prefix = DBG_PARENT case ( \"CHILD\" ) prefix = DBG_CHILD case ( \"SIBLING\" ) prefix = DBG_SIBLING case ( \"LEVEL\" ) prefix = DBG_LEVEL case default prefix = \"INFO: \" end select else prefix = \"INFO: \" endif select case ( level ) case ( DEBUG_ERROR ) write ( output_unit , '(A,1X,A)' ) \"ERROR:\" , trim ( message ) ! Changed format if ( present ( error_code )) write ( output_unit , '(A,1X,I0)' ) \"Code:\" , error_code ! Changed format case ( DEBUG_INFO ) write ( output_unit , '(A,1X,A)' ) trim ( prefix ), trim ( message ) ! Changed format end select endif end subroutine !> Wrapper subroutine for parsing YAML files !! !! @param[in] filename Name of the YAML file to parse !! @param[out] docs Array of parsed YAML documents !! @param[out] status Status code indicating success or error subroutine parse_yaml_wrapper ( filename , docs , status ) character ( len =* ), intent ( in ) :: filename type ( yaml_document ), allocatable , intent ( out ) :: docs (:) integer , intent ( out ) :: status integer :: doc_count logical :: found_doc_marker ! First pass: Count documents call count_documents ( filename , size_out = doc_count , found_marker = found_doc_marker , stat = status ) if ( status /= ERR_SUCCESS ) return ! If no explicit markers but content exists, treat as single document if ( doc_count == 0 . and . . not . found_doc_marker ) doc_count = 1 ! Allocate documents array if ( allocated ( docs )) deallocate ( docs ) if ( doc_count > 0 ) then allocate ( docs ( doc_count ), stat = status ) if ( status /= ERR_SUCCESS ) return endif ! Parse documents call parse_yaml_internal ( filename , docs , status ) end subroutine !> Helper subroutine to count the number of YAML documents in a file !! !! @param[in] filename Name of the YAML file to count documents in !! @param[out] size_out Number of documents found !! @param[out] found_marker Logical flag indicating if document markers were found !! @param[out] stat Status code indicating success or error subroutine count_documents ( filename , size_out , found_marker , stat ) character ( len =* ), intent ( in ) :: filename integer , intent ( out ) :: size_out logical , intent ( out ) :: found_marker integer , intent ( out ) :: stat integer :: unit_num , io_stat character ( len = 1024 ) :: line size_out = 0 found_marker = . false . open ( newunit = unit_num , file = filename , status = 'old' , action = 'read' , iostat = io_stat ) if ( io_stat /= 0 ) then stat = ERR_FILE return endif do read ( unit_num , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( line ( 1 : 3 ) == '---' ) then found_marker = . true . size_out = size_out + 1 endif enddo close ( unit_num ) stat = ERR_SUCCESS end subroutine !> Internal subroutine for parsing YAML files !! !! @param[in] filename Name of the YAML file to parse !! @param[out] docs Array of parsed YAML documents !! @param[out] status Status code indicating success or error subroutine parse_yaml_internal ( filename , docs , status ) character ( len =* ), intent ( in ) :: filename type ( yaml_document ), allocatable , intent ( out ) :: docs (:) integer , intent ( out ) :: status integer :: unit_num , io_stat , line_count , doc_count , current_line character ( len = 1024 ) :: line logical :: in_document , doc_started , has_doc_markers integer :: i character ( len = 256 ) :: error_msg , debug_msg ! Added debug_msg here character ( len = 32 ) :: cnt_str ! Initialize status and counters status = ERR_SUCCESS has_doc_markers = . false . line_count = 0 ! Total lines in file current_line = 0 ! Current line being processed call debug_print ( DEBUG_INFO , \"Starting YAML parse for: \" // trim ( filename )) ! Open the YAML file for reading open ( newunit = unit_num , file = filename , status = 'old' , action = 'read' , iostat = io_stat ) if ( io_stat /= 0 ) then write ( error_msg , '(A,I0)' ) \"Failed to open file. IO Status: \" , io_stat call debug_print ( DEBUG_ERROR , trim ( error_msg )) status = ERR_FILE return endif call debug_print ( DEBUG_INFO , \"Counting documents in file\" ) ! First Pass: Look for document markers and count documents doc_count = 0 line_count = 0 in_document = . false . do read ( unit_num , '(A)' , IOSTAT = io_stat ) line if ( io_stat == - 1 ) exit ! EOF reached if ( io_stat /= 0 ) then write ( error_msg , '(A,I0)' ) \"Error reading file during document count. IO Status: \" , io_stat call debug_print ( DEBUG_ERROR , trim ( error_msg )) status = ERR_FILE close ( unit_num ) return endif line_count = line_count + 1 line = adjustl ( line ) if ( starts_with_trimmed ( line , '---' )) then doc_count = doc_count + 1 has_doc_markers = . true . in_document = . true . endif ! Check for document end marker if ( starts_with_trimmed ( line , '...' )) then in_document = . false . has_doc_markers = . true . endif end do ! If no document markers found, treat as single document if (. not . has_doc_markers . and . line_count > 0 ) then doc_count = 1 call debug_print ( DEBUG_INFO , \"No document markers found, treating as single document\" ) else if ( doc_count == 0 . and . line_count > 0 ) then ! At least one document exists even if only markers found doc_count = 1 endif write ( cnt_str , '(I0)' ) doc_count call debug_print ( DEBUG_INFO , \"Number of YAML documents found: \" // trim ( adjustl ( cnt_str ))) rewind ( unit_num ) ! Allocate the documents array if ( doc_count > 0 ) then allocate ( docs ( doc_count )) do i = 1 , doc_count call initialize_document ( docs ( i )) end do else ! No documents found write ( error_msg , '(A)' ) \"No YAML documents found in the file.\" call debug_print ( DEBUG_INFO , trim ( error_msg )) status = ERR_PARSE close ( unit_num ) return endif ! Second Pass: Parse each YAML document doc_count = 1 in_document = . not . has_doc_markers ! Start in document if no markers doc_started = . not . has_doc_markers ! Document started if no markers current_line = 0 ! Reset line counter for second pass call debug_print ( DEBUG_INFO , \"Parsing documents\" ) do read ( unit_num , '(A)' , IOSTAT = io_stat ) line if ( io_stat == - 1 ) exit ! EOF reached if ( io_stat /= 0 ) then write ( error_msg , '(A,I0)' ) \"Error reading file during parsing. IO Status: \" , io_stat call debug_print ( DEBUG_ERROR , trim ( error_msg )) status = ERR_FILE exit endif current_line = current_line + 1 ! Increment line counter for each line read write ( debug_msg , '(A,I0,A)' ) \"Processing line \" , current_line , \": \" // trim ( line ) call debug_print ( DEBUG_INFO , debug_msg ) if ( has_doc_markers ) then if ( starts_with_trimmed ( line , '---' )) then ! New document starts if ( doc_count > size ( docs )) then write ( error_msg , '(A)' ) \"Document count exceeded allocation.\" call debug_print ( DEBUG_ERROR , trim ( error_msg )) status = ERR_PARSE exit endif if ( in_document ) then ! Finalize the previous document if needed doc_count = doc_count + 1 if ( doc_count > size ( docs )) then call debug_print ( DEBUG_ERROR , \"Exceeded allocated document count.\" ) status = ERR_PARSE exit endif else in_document = . true . doc_started = . true . endif cycle ! Skip the '---' line endif if ( starts_with_trimmed ( line , '...' )) then in_document = . false . cycle ! Skip the '...' line endif endif if ( in_document . or . . not . has_doc_markers ) then ! Parse the line into the current document call parse_line ( line , docs ( doc_count ), status , current_line ) ! Pass current_line instead of line_count if ( status /= ERR_SUCCESS ) then call debug_print ( DEBUG_ERROR , \"Error parsing line \" // trim ( integer_to_string ( current_line )) // \": \" // trim ( line )) exit endif endif end do close ( unit_num ) ! Final checks after parsing if (. not . doc_started . and . line_count > 0 ) then write ( error_msg , '(A)' ) \"No valid YAML documents were parsed.\" call debug_print ( DEBUG_INFO , trim ( error_msg )) status = ERR_PARSE else call debug_print ( DEBUG_INFO , \"YAML parsing completed successfully.\" ) status = ERR_SUCCESS endif ! Clean up indent history call cleanup_indent_history () end subroutine parse_yaml_internal !> Initialize a new YAML document !! !! Sets up empty document structure with nullified root !! !! @param[in,out] doc Document to initialize subroutine initialize_document ( doc ) implicit none type ( yaml_document ), intent ( inout ) :: doc ! Only initialize root node nullify ( doc % root ) end subroutine !> Parse a single line of YAML content !! !! Processes a line and updates document structure. Handles: !! - Indentation !! - Sequence items !! - Key-value pairs !! - Nested structures !! !! @param[in]     line Input line !! @param[in,out] doc  Document being built !! @param[out]    status Status code !! @param[in]     line_num Line number of the input line subroutine parse_line ( line , doc , status , line_num ) character ( len =* ), intent ( in ) :: line type ( yaml_document ), intent ( inout ) :: doc integer , intent ( out ) :: status integer , intent ( in ) :: line_num ! Add line number parameter type ( yaml_node ), pointer :: new_node , current_node , parent_node integer :: pos , current_indent , parent_indent , io_stat character ( len = :), allocatable :: local_line , parent_key logical :: is_sequence_item character ( len = 256 ) :: debug_msg , error_msg ! Added error_msg here call debug_print ( DEBUG_INFO , \"Parsing line: \" // trim ( line )) ! Validate input if ( len_trim ( line ) == 0 ) then call debug_print ( DEBUG_INFO , \"Empty line received\" ) status = ERR_SUCCESS return endif ! Create local copy and remove comments local_line = trim ( line ) pos = index ( local_line , '#' ) if ( pos > 0 ) local_line = trim ( local_line ( 1 : pos - 1 )) if ( len_trim ( local_line ) == 0 ) return ! Determine indentation and sequence status current_indent = count_leading_spaces ( line ) is_sequence_item = is_block_sequence ( adjustl ( local_line )) ! Changed to use is_block_sequence ! ! Memory allocation and validation checks ! if (.not. associated(new_node)) then !     call debug_print(DEBUG_ERROR, \"Node pointer not associated\", ERR_MEMORY) !     status = ERR_MEMORY !     return ! endif new_node => null () ! Create new node allocate ( new_node , stat = io_stat ) if ( io_stat == 0 ) then call initialize_node ( new_node ) write ( debug_msg , DBG_FMT_INDENT ) \"Created node with indent \" , & trim ( integer_to_string ( count_leading_spaces ( line ))) call debug_print ( DEBUG_INFO , debug_msg , msg_type = \"NEW_NODE\" ) else call debug_print ( DEBUG_ERROR , \"Failed to allocate new node\" , ERR_MEMORY ) status = ERR_MEMORY return endif ! Initialize node call initialize_node ( new_node ) call debug_print ( DEBUG_INFO , \"Successfully created and initialized new node\" ) ! Validate node initialization if (. not . associated ( new_node )) then call debug_print ( DEBUG_ERROR , \"Node initialization failed\" , ERR_MEMORY ) status = ERR_MEMORY return endif ! Store indentation level in node new_node % indent = count_leading_spaces ( line ) ! Store line number in node new_node % line_num = line_num write ( debug_msg , '(A,I0,A,I0)' ) \"Created node at line \" , line_num , & \" with indent \" , new_node % indent call debug_print ( DEBUG_INFO , debug_msg ) ! Record indent level if ( len_trim ( new_node % key ) > 0 ) then call record_indent_level ( current_indent , new_node % key , line_num ) endif ! Parse sequence item if ( is_sequence_item ) then ! Add more detailed debug output write ( debug_msg , '(A,A)' ) \"Processing sequence item with indent: \" , trim ( adjustl ( integer_to_string ( current_indent ))) call debug_print ( DEBUG_INFO , debug_msg ) ! Clean leading spaces and dashes more carefully local_line = adjustl ( local_line ) if ( local_line ( 1 : 2 ) == '- ' ) then local_line = adjustl ( local_line ( 3 :)) endif new_node % value = trim ( local_line ) new_node % is_sequence = . true . new_node % indent = current_indent ! Ensure indent is set ! Find parent node based on indentation parent_node => find_block_sequence_parent ( doc % root , new_node ) if ( associated ( parent_node )) then ! Set sequence flags parent_node % is_sequence = . true . ! Use parent's key for sequence context new_node % key = trim ( parent_node % key ) ! Link as child of parent if (. not . associated ( parent_node % children )) then parent_node % children => new_node else ! Find end of children list current_node => parent_node % children do while ( associated ( current_node % next )) current_node => current_node % next end do current_node % next => new_node endif status = ERR_SUCCESS else ! If no parent found, try to add at root level if (. not . associated ( doc % root )) then doc % root => new_node else current_node => doc % root do while ( associated ( current_node % next )) current_node => current_node % next end do current_node % next => new_node endif status = ERR_SUCCESS endif return endif ! Parse flow-style sequences and mappings - SINGLE BLOCK HERE if ( index ( line , '[' ) > 0 . or . index ( line , '{' ) > 0 ) then pos = index ( local_line , ':' ) if ( pos > 0 ) then ! Set up the node new_node % key = trim ( local_line ( 1 : pos - 1 )) new_node % value = trim ( adjustl ( local_line ( pos + 1 :))) new_node % indent = current_indent ! Mark as sequence if it's a flow sequence new_node % is_sequence = ( index ( new_node % value , '[' ) > 0 ) if ( new_node % is_sequence ) then call debug_print ( DEBUG_INFO , \"Found flow sequence: \" // trim ( new_node % value )) endif ! Find parent based on indentation parent_node => find_parent_by_indent ( doc % root , current_indent , line_num ) if ( associated ( parent_node )) then call debug_print ( DEBUG_INFO , \"Found parent for flow sequence: \" // trim ( parent_node % key )) ! Link as child if (. not . associated ( parent_node % children )) then parent_node % children => new_node else current_node => parent_node % children do while ( associated ( current_node % next )) current_node => current_node % next end do current_node % next => new_node endif new_node % parent => parent_node else ! Root level node if (. not . associated ( doc % root )) then doc % root => new_node else current_node => doc % root do while ( associated ( current_node % next )) current_node => current_node % next end do current_node % next => new_node endif endif ! Now parse the flow sequence content if ( new_node % is_sequence ) then call parse_flow_form ( new_node % value , new_node ) endif status = ERR_SUCCESS return endif else ! Regular key-value parsing pos = index ( local_line , ':' ) if ( pos > 0 ) then write ( debug_msg , '(A,A)' ) \"Parsing key-value line: \" , trim ( local_line ) call debug_print ( DEBUG_INFO , debug_msg ) new_node % key = trim ( local_line ( 1 : pos - 1 )) new_node % value = trim ( adjustl ( local_line ( pos + 1 :))) new_node % indent = current_indent ! Find parent based on indentation parent_node => find_parent_by_indent ( doc % root , current_indent , line_num ) write ( debug_msg , '(A,A,A,I0,A,L1)' ) \"Node: \" , trim ( new_node % key ), & \" at indent \" , current_indent , & \" is root: \" , ( current_indent == 0 ) call debug_print ( DEBUG_INFO , debug_msg ) if ( current_indent == 0 ) then ! Root level node - append to root level if (. not . associated ( doc % root )) then doc % root => new_node else current_node => doc % root do while ( associated ( current_node % next )) current_node => current_node % next end do current_node % next => new_node endif nullify ( new_node % parent ) ! Ensure no parent for root nodes else if ( associated ( parent_node )) then write ( debug_msg , '(A,A,A,I0)' ) \"Found parent '\" , trim ( parent_node % key ), & \"' at indent \" , parent_node % indent call debug_print ( DEBUG_INFO , trim ( debug_msg )) ! Set bidirectional parent-child relationship new_node % parent => parent_node ! Add as child, properly handling the children list if (. not . associated ( parent_node % children )) then parent_node % children => new_node else ! Find the last child in the chain current_node => parent_node % children do while ( associated ( current_node % next )) current_node => current_node % next end do current_node % next => new_node endif ! Added: Update sequence flags if needed if ( parent_node % is_sequence ) then new_node % is_sequence = . true . endif else ! No valid parent found for non-root node - error write ( error_unit , * ) \"ERROR: No valid parent found for node at line\" , line_num status = ERR_PARSE return endif ! Debug output for node hierarchy if ( associated ( new_node % parent )) then write ( debug_msg , '(A,A,A,A)' ) \"Node \" , trim ( new_node % key ), & \" has parent \" , trim ( new_node % parent % key ) else write ( debug_msg , '(A,A,A)' ) \"Node \" , trim ( new_node % key ), & \" is at root level\" endif call debug_print ( DEBUG_INFO , debug_msg ) status = ERR_SUCCESS return endif endif ! Link node into document structure if (. not . associated ( doc % root )) then doc % root => new_node status = ERR_SUCCESS return endif ! Find correct parent based on indentation current_node => doc % root parent_node => null () parent_indent = 0 do while ( associated ( current_node )) if ( current_indent > parent_indent ) then ! Going deeper in hierarchy if (. not . associated ( current_node % children )) then current_node % children => new_node status = ERR_SUCCESS return endif parent_node => current_node current_node => current_node % children parent_indent = parent_indent + 2 else if ( current_indent == parent_indent ) then ! Same level - add as sibling if (. not . associated ( current_node % next )) then current_node % next => new_node status = ERR_SUCCESS return endif current_node => current_node % next else ! Going back up in hierarchy if ( associated ( parent_node )) then current_node => parent_node parent_node => null () parent_indent = parent_indent - 2 else current_node % next => new_node status = ERR_SUCCESS return endif endif end do end subroutine parse_line !> Find or create intermediate nodes to match target indentation !! !! @param[inout] parent Parent node to start from !! @param[in] target_indent Target indentation level !! @param[in] new_node Node to link at target indentation !! @return Last node created or found at target indentation function find_or_create_intermediate_nodes ( parent , target_indent , new_node ) result ( last_node ) type ( yaml_node ), pointer , intent ( inout ) :: parent integer , intent ( in ) :: target_indent type ( yaml_node ), pointer , intent ( in ) :: new_node type ( yaml_node ), pointer :: last_node , current_node , prev_node integer :: current_indent character ( len = 256 ) :: debug_msg nullify ( last_node ) current_indent = parent % indent + indent_width prev_node => parent do while ( current_indent < target_indent ) ! Find existing node at this indent level current_node => prev_node % children do while ( associated ( current_node )) if ( current_node % indent == current_indent ) then prev_node => current_node exit endif current_node => current_node % next end do if (. not . associated ( current_node )) then ! Need to create intermediate node allocate ( current_node ) call initialize_node ( current_node ) current_node % indent = current_indent ! Link to parent if (. not . associated ( prev_node % children )) then prev_node % children => current_node else current_node % next => prev_node % children prev_node % children => current_node endif prev_node => current_node endif current_indent = current_indent + indent_width end do ! Link final node if (. not . associated ( prev_node % children )) then prev_node % children => new_node else current_node => prev_node % children do while ( associated ( current_node % next )) current_node => current_node % next end do current_node % next => new_node endif last_node => new_node end function find_or_create_intermediate_nodes !> Handle block sequence items, ensuring they're properly linked and labeled !! !! @param[in] line Input line containing sequence item !! @param[inout] doc Document being built !! @param[inout] node Node representing the sequence item !! @param[out] status Status code indicating success or error subroutine handle_block_sequence ( line , doc , node , status ) character ( len =* ), intent ( in ) :: line type ( yaml_document ), intent ( inout ) :: doc type ( yaml_node ), pointer , intent ( inout ) :: node integer , intent ( out ) :: status type ( yaml_node ), pointer :: parent ! Set sequence flags and get indentation node % is_sequence = . true . ! Mark current node as sequence parent => find_sequence_parent_node ( doc % root , node ) ! Set parent sequence flags if ( associated ( parent )) then parent % is_sequence = . true . ! Mark parent as sequence container if ( associated ( parent % children )) then parent % children % is_sequence = . true . ! Mark children as sequence items endif ! Set key from parent if not already set if ( len_trim ( node % key ) == 0 ) then node % key = trim ( adjustl ( parent % key )) endif endif ! Set root sequence flags if needed if (. not . associated ( parent ) . and . associated ( doc % root )) then doc % root % is_sequence = . true . if ( associated ( doc % root % children )) then doc % root % children % is_sequence = . true . endif endif status = ERR_SUCCESS end subroutine handle_block_sequence !> Find the last sequence item at a given indentation level !! !! @param[in] root Root node to start search from !! @param[in] indent Indentation level to search for !! @return Last sequence item found at the given indentation level function find_last_sequence_item ( root , indent ) result ( last_item ) type ( yaml_node ), pointer :: root , last_item integer , intent ( in ) :: indent type ( yaml_node ), pointer :: current last_item => null () current => root do while ( associated ( current )) if ( current % is_sequence . and . count_leading_spaces ( current % value ) == indent ) then last_item => current endif current => current % next end do end function !> Check if node has a sequence parent at given indent !! !! @param[in] root Root node to start search from !! @param[in] indent Indentation level to check for parent !! @return True if a sequence parent is found at the given indent function has_sequence_parent ( root , indent ) result ( has_parent ) type ( yaml_node ), pointer :: root integer , intent ( in ) :: indent logical :: has_parent type ( yaml_node ), pointer :: current has_parent = . false . current => root do while ( associated ( current )) if ( count_leading_spaces ( current % value ) < indent . and . & len_trim ( current % key ) > 0 ) then has_parent = . true . return endif current => current % next end do end function !> Find the parent key for a sequence !! !! @param[in] root Root node to start search from !! @param[in] indent Indentation level to search for parent key !! @param[out] parent_key Key of the parent node found subroutine find_sequence_parent ( root , indent , parent_key ) type ( yaml_node ), pointer :: root integer , intent ( in ) :: indent character ( len = :), allocatable , intent ( out ) :: parent_key type ( yaml_node ), pointer :: current integer :: current_indent parent_key = '' current => root do while ( associated ( current )) current_indent = count_leading_spaces ( current % value ) if ( current_indent < indent . and . len_trim ( current % key ) > 0 ) then parent_key = current % key return endif current => current % next end do end subroutine !> Parse flow-style YAML syntax !! !! Handles flow-style sequences [...] and mappings {...} !! !! @param[in] line Input containing flow syntax !! @param[inout] node Node to store parsed content subroutine parse_flow_form ( line , node ) character ( len =* ), intent ( in ) :: line type ( yaml_node ), pointer , intent ( inout ) :: node integer :: pos , start , end , item_start , item_end character ( len = :), allocatable :: content , item type ( yaml_node ), pointer :: current_item , prev_item logical :: in_quotes , in_bracket ! Initialize in_quotes = . false . in_bracket = . false . nullify ( prev_item ) ! Handle flow form sequences if ( index ( line , '[' ) > 0 ) then start = index ( line , '[' ) end = index ( line , ']' ) if ( end > start ) then content = trim ( adjustl ( line ( start + 1 : end - 1 ))) call debug_print ( DEBUG_INFO , \"Processing sequence content: \" // trim ( content )) ! Parse items item_start = 1 do pos = 1 , len_trim ( content ) select case ( content ( pos : pos )) case ( '\"' ) in_quotes = . not . in_quotes case ( ',' ) if (. not . in_quotes ) then ! Extract item item = trim ( adjustl ( content ( item_start : pos - 1 ))) call add_sequence_item ( node , item ) item_start = pos + 1 endif end select end do ! Handle last item if ( item_start <= len_trim ( content )) then item = trim ( adjustl ( content ( item_start :))) call add_sequence_item ( node , item ) endif endif endif end subroutine parse_flow_form !> Add a new item to a sequence node !! !! @param[inout] parent Parent node representing the sequence !! @param[in] value Value of the new sequence item subroutine add_sequence_item ( parent , value ) type ( yaml_node ), pointer , intent ( inout ) :: parent character ( len =* ), intent ( in ) :: value type ( yaml_node ), pointer :: new_item , current character ( len = :), allocatable :: clean_value ! Clean the value clean_value = trim ( adjustl ( value )) if ( len ( clean_value ) >= 2 ) then if ( clean_value ( 1 : 1 ) == '\"' . and . clean_value ( len_trim ( clean_value ): len_trim ( clean_value )) == '\"' ) then clean_value = clean_value ( 2 : len_trim ( clean_value ) - 1 ) endif endif ! Create new item allocate ( new_item ) call initialize_node ( new_item ) new_item % value = clean_value new_item % is_sequence = . true . ! Add to parent's children if (. not . associated ( parent % children )) then parent % children => new_item else current => parent % children do while ( associated ( current % next )) current => current % next end do current % next => new_item endif end subroutine add_sequence_item !> Parse mapping elements from flow style !! !! Splits comma-separated key-value pairs into nodes !! !! @param[inout] content Mapping content string !! @param[inout] node Node to store mapping subroutine parse_mapping ( content , node ) character ( len =* ), intent ( inout ) :: content type ( yaml_node ), pointer , intent ( inout ) :: node character ( len = :), allocatable :: key , value character ( len = :), allocatable :: local_content , pair integer :: pos , content_len ! Safely initialize local content content_len = len_trim ( content ) if ( content_len == 0 ) return allocate ( character ( len = content_len ) :: local_content ) local_content = trim ( content ) ! Process key-value pairs do while ( len_trim ( local_content ) > 0 ) ! Get next pair pos = index ( local_content , ',' ) if ( pos > 0 ) then if ( allocated ( pair )) deallocate ( pair ) allocate ( character ( len = pos - 1 ) :: pair ) pair = trim ( local_content ( 1 : pos - 1 )) local_content = trim ( local_content ( pos + 1 :)) else if ( allocated ( pair )) deallocate ( pair ) allocate ( character ( len = len_trim ( local_content )) :: pair ) pair = trim ( local_content ) local_content = '' end if ! Process key-value pair pos = index ( pair , ':' ) if ( pos > 0 ) then if ( allocated ( key )) deallocate ( key ) if ( allocated ( value )) deallocate ( value ) allocate ( character ( len = pos - 1 ) :: key ) allocate ( character ( len = len_trim ( pair ) - pos ) :: value ) key = trim ( pair ( 1 : pos - 1 )) value = trim ( pair ( pos + 1 :)) ! Create new node allocate ( node % children ) call initialize_node ( node % children ) node % children % key = key node % children % value = value node => node % children end if end do ! Clean up if ( allocated ( local_content )) deallocate ( local_content ) if ( allocated ( key )) deallocate ( key ) if ( allocated ( value )) deallocate ( value ) if ( allocated ( pair )) deallocate ( pair ) end subroutine parse_mapping !> Initialize a new YAML node !! !! Sets default values for a newly created node !! !! @param[in,out] node Node to initialize subroutine initialize_node ( node ) type ( yaml_node ), pointer , intent ( inout ) :: node node % key = '' node % value = '' node % children => null () node % next => null () node % is_sequence = . false . node % is_null = . false . node % is_boolean = . false . node % is_integer = . false . node % is_float = . false . node % is_string = . true . end subroutine initialize_node !> Determine value type of node !! !! Checks content and sets appropriate type flags !! !! @param[in,out] node Node to analyze subroutine determine_value_type ( node ) type ( yaml_node ), intent ( inout ) :: node real :: r_value integer :: i_value logical :: l_value logical :: is_real , is_int integer :: rc character ( len = 32 ) :: temp_str ! Buffer for numeric conversions ! Early exit for empty values if ( len_trim ( node % value ) == 0 ) then node % is_null = . true . return end if ! Check for null values if ( to_lower ( trim ( node % value )) == 'null' . or . & trim ( node % value ) == '~' . or . & to_lower ( trim ( node % value )) == 'nan' ) then node % is_null = . true . node % value = '' return end if ! Check for boolean values if ( trim ( node % value ) == 'true' . or . trim ( node % value ) == 'false' ) then node % is_boolean = . true . l_value = ( trim ( node % value ) == 'true' ) write ( temp_str , '(L1)' , iostat = rc ) l_value if ( rc == 0 ) node % value = trim ( temp_str ) return end if ! Check for float values if ( is_real_string ( trim ( node % value ))) then read ( node % value , * , iostat = rc ) r_value if ( rc == 0 ) then node % is_float = . true . write ( temp_str , '(G14.6)' , iostat = rc ) r_value if ( rc == 0 ) node % value = trim ( temp_str ) return end if end if ! Check for integer values if ( is_int_string ( trim ( node % value ))) then read ( node % value , * , iostat = rc ) i_value if ( rc == 0 ) then node % is_integer = . true . write ( temp_str , '(I0)' , iostat = rc ) i_value if ( rc == 0 ) node % value = trim ( temp_str ) return end if end if ! Default to string node % is_string = . true . end subroutine determine_value_type !> Count leading spaces in a string !! !! Used for determining indentation level !! !! @param[in]  line Input string !! @return     Number of leading spaces integer function count_leading_spaces ( line ) implicit none character ( len =* ), intent ( in ) :: line integer :: i count_leading_spaces = 0 do i = 1 , len ( line ) if ( line ( i : i ) /= ' ' ) exit count_leading_spaces = count_leading_spaces + 1 end do end function count_leading_spaces !> Check if string can be parsed as real number !! !! @param[in]  str String to check !! @return     True if string represents a real number function is_real_string ( str ) result ( is_real ) implicit none character ( len =* ), intent ( in ) :: str logical :: is_real real :: r_value integer :: iostat read ( str , * , iostat = iostat ) r_value if ( iostat == 0 ) then is_real = . true . else is_real = . false . end if end function is_real_string !> Check if string represents an integer !! !! @param[in] str String to check !! @return True if string can be parsed as integer function is_int_string ( str ) result ( is_int ) implicit none character ( len =* ), intent ( in ) :: str logical :: is_int integer :: i_value integer :: iostat read ( str , * , iostat = iostat ) i_value if ( iostat == 0 ) then is_int = . true . else is_int = . false . end if end function is_int_string !> Convert string to lowercase !! !! @param[in]  str Input string !! @return     Lowercase version of input function to_lower ( str ) result ( lower_str ) implicit none character ( len =* ), intent ( in ) :: str character ( len = len ( str )) :: lower_str integer :: i lower_str = str do i = 1 , len ( str ) if ( iachar ( str ( i : i )) >= iachar ( 'A' ) . and . iachar ( str ( i : i )) <= iachar ( 'Z' )) then lower_str ( i : i ) = achar ( iachar ( str ( i : i )) + 32 ) end if end do end function to_lower !> Validate node structure and contents !! !! Performs validation checks on node pointers and content !! !! @param[in] node Node to validate !! @param[out] status Status code (ERR_SUCCESS if valid) subroutine validate_node ( node , status ) type ( yaml_node ), pointer , intent ( in ) :: node integer , intent ( out ) :: status if (. not . associated ( node )) then call debug_print ( DEBUG_ERROR , \"Invalid node pointer\" , ERR_PARSE ) status = ERR_PARSE return endif ! Validate node contents if ( node % is_sequence . and . . not . associated ( node % children )) then call debug_print ( DEBUG_INFO , \"Sequence node without children\" ) endif status = ERR_SUCCESS end subroutine validate_node !> Check if a trimmed line starts with a specific string !! !! @param[in] line   Input line !! @param[in] prefix Prefix string to check !! @return     True if the trimmed line starts with the prefix logical function starts_with_trimmed ( line , prefix ) implicit none character ( len =* ), intent ( in ) :: line character ( len =* ), intent ( in ) :: prefix character ( len = :), allocatable :: trimmed_line trimmed_line = trim ( adjustl ( line )) if ( len ( trimmed_line ) < len ( prefix )) then starts_with_trimmed = . false . else starts_with_trimmed = ( trimmed_line ( 1 : len ( prefix )) == trim ( prefix )) endif end function starts_with_trimmed !> Check if string represents a block sequence !! !! @param[in] str String to check !! @return True if string is a block sequence function is_block_sequence ( str ) result ( is_block ) implicit none character ( len =* ), intent ( in ) :: str logical :: is_block is_block = ( len_trim ( str ) >= 2 . and . str ( 1 : 2 ) == '- ' ) end function is_block_sequence !> Find the last non-sequence node (likely parent) !! !! @param[in] root Root node to start search from !! @return Last non-sequence node found function find_last_nonsequence_node ( root ) result ( last_node ) type ( yaml_node ), pointer :: root , last_node type ( yaml_node ), pointer :: current last_node => null () current => root do while ( associated ( current )) if (. not . current % is_sequence . and . len_trim ( current % key ) > 0 ) then last_node => current endif current => current % next end do end function !> Find parent node for block sequence item !! !! @param[in] root Root node to start search from !! @param[in] item_node Node representing the sequence item !! @return Parent node found for the sequence item function find_block_sequence_parent ( root , item_node ) result ( parent ) type ( yaml_node ), pointer :: root , parent , item_node character ( len = 256 ) :: debug_msg type ( yaml_node ), pointer :: current , best_candidate type ( stack_entry ), allocatable :: stack (:) ! Now stack_entry is defined integer :: item_indent , current_indent , indent_level , stack_top , alloc_stat logical :: found_match integer , parameter :: MAX_STACK = 100 nullify ( parent ) nullify ( best_candidate ) found_match = . false . ! Allocate stack allocate ( stack ( MAX_STACK ), stat = alloc_stat ) if ( alloc_stat /= 0 ) then write ( debug_msg , * ) \"Failed to allocate stack\" call debug_print ( DEBUG_INFO , trim ( debug_msg )) return endif stack_top = 0 ! Initialize stack if (. not . associated ( root )) then deallocate ( stack ) return endif item_indent = item_node % indent indent_level = - 1 ! Track maximum indent level seen write ( debug_msg , * ) \"Finding parent for sequence item at indent:\" , item_indent call debug_print ( DEBUG_INFO , trim ( debug_msg )) ! Start with root node current => root do while ( associated ( current )) ! Check current node if ( len_trim ( current % key ) > 0 ) then current_indent = current % indent write ( debug_msg , * ) \"Examining node: '\" , trim ( current % key ), & \"' at indent:\" , current_indent call debug_print ( DEBUG_INFO , trim ( debug_msg )) ! Check if this could be a better parent if ( current_indent < item_indent ) then if ( current_indent > indent_level ) then best_candidate => current indent_level = current_indent found_match = . true . write ( debug_msg , * ) \"New best parent: \" , trim ( current % key ), & \" at indent:\" , current_indent call debug_print ( DEBUG_INFO , trim ( debug_msg )) else if ( associated ( best_candidate )) then if ( trim ( current % key ) . ne . trim ( best_candidate % key )) then best_candidate => current indent_level = current_indent found_match = . true . write ( debug_msg , * ) \"New best parent (different key): \" , & trim ( current % key ), \" at indent:\" , current_indent call debug_print ( DEBUG_INFO , trim ( debug_msg )) endif endif endif endif ! Depth-first traversal using a stack ! If there are children, push current to stack and go to children if ( associated ( current % children )) then if ( stack_top < MAX_STACK ) then stack_top = stack_top + 1 stack ( stack_top )% node => current current => current % children cycle endif endif ! If there's a next sibling, go to it if ( associated ( current % next )) then current => current % next cycle endif ! No children or next siblings, pop from stack and try next do while ( stack_top > 0 ) current => stack ( stack_top )% node stack_top = stack_top - 1 if ( associated ( current % next )) then current => current % next exit endif end do ! If stack is empty and no more nodes to process if ( stack_top == 0 . and . . not . associated ( current % next )) exit end do ! Use the best candidate found if ( found_match . and . associated ( best_candidate )) then parent => best_candidate write ( debug_msg , * ) \"Selected parent: \" , trim ( parent % key ), & \" at indent:\" , parent % indent call debug_print ( DEBUG_INFO , trim ( debug_msg )) else write ( debug_msg , * ) \"No suitable parent found for sequence at indent:\" , item_indent call debug_print ( DEBUG_INFO , trim ( debug_msg )) endif ! Clean up deallocate ( stack ) end function find_block_sequence_parent !> Detect indentation width from sequence structure !! !! @param[in] root Root node to start search from !! @param[in] item_indent Indentation level of the item !! @return Detected indentation width function detect_indent_width ( root , item_indent ) result ( width ) type ( yaml_node ), pointer , intent ( in ) :: root integer , intent ( in ) :: item_indent integer :: width type ( yaml_node ), pointer :: current logical :: found_parent ! Start with default width = indent_width found_parent = . false . ! Look for closest parent mapping with less indentation current => root do while ( associated ( current )) if ( len_trim ( current % key ) > 0 . and . & ! Has key (is mapping) current % indent < item_indent . and . & ! Less indented than item . not . current % is_sequence ) then ! Not a sequence item itself ! Found potential parent if (. not . found_parent ) then width = item_indent - current % indent found_parent = . true . else if ( current % indent > root % indent ) then ! Use closest parent's indentation difference width = item_indent - current % indent endif endif current => current % next end do end function detect_indent_width !> Find parent node containing key for sequence !! !! @param[in] root Root node to start search from !! @param[in] current Node representing the sequence item !! @return Parent node found for the sequence item function find_sequence_parent_node ( root , current ) result ( parent ) type ( yaml_node ), pointer , intent ( in ) :: root , current type ( yaml_node ), pointer :: parent , temp integer :: current_indent , temp_indent character ( len = 256 ) :: debug_msg nullify ( parent ) if (. not . associated ( root )) return current_indent = count_leading_spaces ( current % value ) temp => root ! Add debug output for node traversal write ( debug_msg , '(A,A)' ) \"Searching for parent of node with value: \" , trim ( current % value ) call debug_print ( DEBUG_INFO , trim ( debug_msg )) ! Add indentation level check if ( current_indent <= 0 ) then write ( debug_msg , '(A,I0)' ) \"Warning: Invalid indentation level: \" , current_indent call debug_print ( DEBUG_INFO , trim ( debug_msg )) endif ! Traverse tree to find closest parent with less indentation do while ( associated ( temp )) temp_indent = count_leading_spaces ( temp % value ) if ( temp_indent < current_indent . and . len_trim ( temp % key ) > 0 ) then write ( debug_msg , '(A,A,A,I0)' ) \"Found potential parent: \" , trim ( temp % key ), & \" at indent: \" , temp_indent call debug_print ( DEBUG_INFO , trim ( debug_msg )) if (. not . associated ( parent ) . or . & temp_indent > count_leading_spaces ( parent % value )) then parent => temp write ( debug_msg , '(A,A)' ) \"Selected as best parent: \" , trim ( parent % key ) call debug_print ( DEBUG_INFO , trim ( debug_msg )) endif endif ! Check children before moving to next sibling if ( associated ( temp % children )) then write ( debug_msg , '(A,A)' ) \"Checking children of node: \" , trim ( temp % key ) call debug_print ( DEBUG_INFO , trim ( debug_msg )) temp => temp % children else if ( associated ( temp % next )) then temp => temp % next else ! Move up and over if no more siblings do while (. not . associated ( temp % next ) . and . associated ( parent )) temp => parent if ( associated ( temp % next )) then temp => temp % next exit endif enddo if (. not . associated ( temp % next )) exit endif end do if (. not . associated ( parent )) then write ( debug_msg , '(A)' ) \"No suitable parent found\" call debug_print ( DEBUG_INFO , trim ( debug_msg )) endif end function find_sequence_parent_node !> Print the structure of a YAML node and its children for debugging !! !! @param[in] node Node to print !! @param[in] prefix Prefix string for indentation !! @param[in] max_depth Optional maximum depth to print recursive subroutine debug_print_node_structure ( node , prefix , max_depth ) type ( yaml_node ), pointer , intent ( in ) :: node character ( len =* ), intent ( in ) :: prefix integer , intent ( in ), optional :: max_depth type ( yaml_node ), pointer :: current character ( len = 256 ) :: debug_msg integer :: current_depth current_depth = 1 if ( present ( max_depth )) then if ( current_depth > max_depth ) return endif current => node do while ( associated ( current )) if ( len_trim ( current % key ) > 0 . or . len_trim ( current % value ) > 0 ) then write ( debug_msg , '(A,A,A,A)' ) prefix , trim ( current % key ), \": \" , trim ( current % value ) call debug_print ( DEBUG_INFO , debug_msg ) endif if ( associated ( current % children )) then if (. not . present ( max_depth ) . or . current_depth < max_depth ) then call debug_print_node_structure ( current % children , trim ( prefix ) // \"  \" , current_depth + 1 ) endif endif current => current % next end do end subroutine debug_print_node_structure !> Find a nested node by key path !! !! @param[in] node Node to start search from !! @param[in] key_path Key path to search for, separated by '%' !! @return Found node matching the key path recursive function find_nested_node ( node , key_path ) result ( found_node ) type ( yaml_node ), pointer :: node , found_node character ( len =* ), intent ( in ) :: key_path integer :: delim_pos character ( len = :), allocatable :: first_key , remaining_path type ( yaml_node ), pointer :: current nullify ( found_node ) if (. not . associated ( node )) return delim_pos = index ( key_path , '%' ) if ( delim_pos > 0 ) then first_key = key_path (: delim_pos - 1 ) remaining_path = key_path ( delim_pos + 1 :) else first_key = key_path remaining_path = '' endif ! Search at current level current => node do while ( associated ( current )) if ( trim ( adjustl ( current % key )) == trim ( adjustl ( first_key ))) then if ( len_trim ( remaining_path ) == 0 ) then found_node => current return else if ( associated ( current % children )) then found_node => find_nested_node ( current % children , remaining_path ) return endif endif current => current % next end do end function find_nested_node !> Check if value is a sequence !! !! @param[in] node Node to check !! @return True if the node represents a sequence function check_sequence_node ( node ) result ( is_seq ) type ( yaml_node ), pointer , intent ( in ) :: node logical :: is_seq type ( yaml_node ), pointer :: current is_seq = . false . if ( associated ( node )) then ! Check node itself if ( node % is_sequence ) then is_seq = . true . return endif ! Check children if ( associated ( node % children )) then current => node % children ! If any child is marked as sequence, the parent is a sequence container do while ( associated ( current )) if ( current % is_sequence ) then is_seq = . true . return endif current => current % next end do endif endif end function check_sequence_node !> Get sequence items as string array !! !! @param[in] node Node representing the sequence !! @return Array of sequence items as strings function get_sequence_as_strings ( node ) result ( items ) type ( yaml_node ), pointer , intent ( in ) :: node character ( len = :), allocatable , dimension (:) :: items type ( yaml_node ), pointer :: current integer :: count , i character ( len = 256 ) :: debug_msg character ( len = :), allocatable :: clean_value ! Count items first count = 0 if ( associated ( node % children )) then current => node % children do while ( associated ( current )) count = count + 1 current => current % next end do endif ! Allocate result array allocate ( character ( len = 32 ) :: items ( count )) ! Fill array with cleaned values if ( count > 0 ) then current => node % children i = 1 do while ( associated ( current )) ! Get value, ensuring to remove any \"- \" prefix clean_value = trim ( adjustl ( current % value )) if ( len ( clean_value ) >= 2 . and . clean_value ( 1 : 2 ) == '- ' ) then clean_value = trim ( adjustl ( clean_value ( 3 :))) endif items ( i ) = clean_value write ( debug_msg , '(A,A,A,I0,A,A)' ) \"Node [\" , trim ( node % key ), \"] Item \" , i , \": \" , trim ( items ( i )) call debug_print ( DEBUG_INFO , debug_msg ) i = i + 1 current => current % next end do endif end function get_sequence_as_strings !> Convert integer to string !! !! @param[in] num Integer to convert !! @return String representation of the integer function integer_to_string ( num ) result ( str ) integer , intent ( in ) :: num character ( len = 32 ) :: str write ( str , '(I0)' ) num end function integer_to_string !> Find parent node by indentation level !! !! @param[in] root Root node to start search from !! @param[in] child_indent Indentation level of the child node !! @param[in] line_num Line number of the child node !! @return Parent node found at the given indentation level function find_parent_by_indent ( root , child_indent , line_num ) result ( parent ) type ( yaml_node ), pointer :: root , parent integer , intent ( in ) :: child_indent , line_num type ( yaml_node ), pointer :: current , best_parent , last_valid_parent type ( stack_entry ), allocatable :: node_stack (:) integer :: stack_top , max_stack_size integer :: parent_level_indent character ( len = 256 ) :: debug_msg logical :: is_root_level type ( yaml_node ), pointer :: latest_root ! Initialize pointers and variables nullify ( parent ) nullify ( best_parent ) nullify ( last_valid_parent ) nullify ( latest_root ) nullify ( current ) ! Early return if root is not associated if (. not . associated ( root )) then call debug_print ( DEBUG_INFO , \"Root node is not associated\" ) return endif ! Check if this is a root-level node (indent 0) is_root_level = ( child_indent == 0 ) if ( is_root_level ) then write ( debug_msg , '(A,I0)' ) \"Root level node detected at line \" , line_num call debug_print ( DEBUG_INFO , debug_msg ) nullify ( parent ) return endif ! Expected parent indent level parent_level_indent = child_indent - indent_width write ( debug_msg , '(A,I0,A,I0,A,I0)' ) & \"Looking for parent at indent \" , parent_level_indent , & \" for child at indent \" , child_indent , & \" at line \" , line_num call debug_print ( DEBUG_INFO , debug_msg ) ! First find the latest root-level node before this line current => root do while ( associated ( current )) if ( current % line_num < line_num . and . current % indent == 0 ) then latest_root => current write ( debug_msg , '(A,A,A,I0)' ) & \"Found potential root-level node: \" , trim ( current % key ), & \" at line \" , current % line_num call debug_print ( DEBUG_INFO , debug_msg ) endif if (. not . associated ( current % next )) exit current => current % next end do ! If no root-level node found, search from the actual root if (. not . associated ( latest_root )) then write ( debug_msg , '(A,I0)' ) & \"No root-level node found before line \" , line_num call debug_print ( DEBUG_INFO , debug_msg ) latest_root => root ! Fall back to using the actual root endif ! Now search for parent starting from latest root node current => latest_root best_parent => null () ! Explicitly nullify best_parent last_valid_parent => null () ! Explicitly nullify last_valid_parent ! Initialize stack for tree traversal with larger size for deep nesting max_stack_size = 1000 allocate ( node_stack ( max_stack_size ), stat = stack_top ) if ( stack_top /= 0 ) then call debug_print ( DEBUG_ERROR , \"Failed to allocate node stack\" ) return endif stack_top = 0 ! Depth-first search with explicit node stack do while ( associated ( current )) ! Check current node as potential parent if ( associated ( current ) . and . len_trim ( current % key ) > 0 ) then ! Only consider nodes before the current line if ( current % line_num < line_num ) then write ( debug_msg , '(A,A,A,I0,A,I0)' ) & \"Checking node: \" , trim ( current % key ), & \" at line \" , current % line_num , & \" indent \" , current % indent call debug_print ( DEBUG_INFO , debug_msg ) ! Check for exact indent match first if ( current % indent == parent_level_indent ) then if (. not . associated ( best_parent )) then best_parent => current write ( debug_msg , '(A,A,A,I0,A,I0)' ) & \"Found exact indent match: \" , trim ( current % key ), & \" at line \" , current % line_num , & \" indent \" , current % indent call debug_print ( DEBUG_INFO , debug_msg ) else if ( associated ( best_parent )) then if ( current % line_num > best_parent % line_num ) then best_parent => current write ( debug_msg , '(A,A,A,I0,A,I0)' ) & \"Found exact indent match: \" , trim ( current % key ), & \" at line \" , current % line_num , & \" indent \" , current % indent call debug_print ( DEBUG_INFO , debug_msg ) endif endif endif ! Then check for closest valid parent with less indentation else if ( current % indent < child_indent . and . & current % indent >= 0 ) then ! First check if we have no valid parent yet if (. not . associated ( last_valid_parent )) then last_valid_parent => current write ( debug_msg , '(A,A,A,I0,A,I0)' ) & \"Found first valid parent: \" , trim ( current % key ), & \" at line \" , current % line_num , & \" indent \" , current % indent call debug_print ( DEBUG_INFO , debug_msg ) else ! Now we know last_valid_parent is associated, can safely check indent if ( current % indent > last_valid_parent % indent ) then last_valid_parent => current write ( debug_msg , '(A,A,A,I0,A,I0)' ) & \"Found better parent (higher indent): \" , trim ( current % key ), & \" at line \" , current % line_num , & \" indent \" , current % indent call debug_print ( DEBUG_INFO , debug_msg ) else if ( current % indent == last_valid_parent % indent . and . & current % line_num > last_valid_parent % line_num ) then last_valid_parent => current write ( debug_msg , '(A,A,A,I0,A,I0)' ) & \"Found better parent (same indent, later line): \" , trim ( current % key ), & \" at line \" , current % line_num , & \" indent \" , current % indent call debug_print ( DEBUG_INFO , debug_msg ) endif endif endif endif endif ! Tree traversal logic - try to go deeper first if ( associated ( current % children )) then ! Push current's next sibling onto stack if ( stack_top < max_stack_size . and . associated ( current % next )) then stack_top = stack_top + 1 node_stack ( stack_top )% node => current % next endif ! Move to children current => current % children else if ( associated ( current % next )) then ! Move to next sibling current => current % next else if ( stack_top > 0 ) then ! Pop from stack current => node_stack ( stack_top )% node stack_top = stack_top - 1 else ! No more nodes to process nullify ( current ) exit endif end do ! Select best parent match if ( associated ( best_parent )) then parent => best_parent write ( debug_msg , '(A,A,A,I0,A,I0)' ) & \"Selected exact match parent: \" , trim ( parent % key ), & \" at line \" , parent % line_num , & \" indent \" , parent % indent call debug_print ( DEBUG_INFO , debug_msg ) else if ( associated ( last_valid_parent )) then parent => last_valid_parent write ( debug_msg , '(A,A,A,I0,A,I0)' ) & \"Selected closest valid parent: \" , trim ( parent % key ), & \" at line \" , parent % line_num , & \" indent \" , parent % indent call debug_print ( DEBUG_INFO , debug_msg ) else write ( debug_msg , '(A,I0,A,I0)' ) & \"No suitable parent found for line \" , line_num , & \" at indent \" , child_indent call debug_print ( DEBUG_INFO , debug_msg ) endif ! Clean up if ( allocated ( node_stack )) deallocate ( node_stack ) end function find_parent_by_indent !> Check key hierarchy for validity !! !! @param[in] current Current node to check !! @param[in] previous Previous node to compare with !! @param[in] target_indent Target indentation level !! @return True if the key hierarchy is valid function check_key_hierarchy ( current , previous , target_indent ) result ( is_valid ) type ( yaml_node ), pointer , intent ( in ) :: current , previous integer , intent ( in ) :: target_indent logical :: is_valid character ( len = 256 ) :: debug_msg is_valid = . true . ! If either node is null, hierarchy is invalid if (. not . associated ( current ) . or . . not . associated ( previous )) then is_valid = . false . return endif ! Check if indentation makes sense if ( current % indent >= target_indent . or . & previous % indent >= target_indent ) then is_valid = . false . return endif ! Check if current node is at same level or higher than previous if ( current % indent > previous % indent ) then is_valid = . false . return endif ! If at same level, check if keys make sense hierarchically if ( current % indent == previous % indent ) then if ( trim ( current % key ) == trim ( previous % key )) then ! Same key at same level is invalid is_valid = . false . endif endif write ( debug_msg , DBG_FMT_KEY ) \"Key hierarchy valid: \" , is_valid if ( is_valid ) then call debug_print ( DEBUG_INFO , debug_msg ) endif end function check_key_hierarchy !> Record the last key at a given indentation level !! !! @param[in] indent Indentation level !! @param[in] key Key to record !! @param[in] line_num Line number of the key subroutine record_indent_level ( indent , key , line_num ) integer , intent ( in ) :: indent , line_num character ( len =* ), intent ( in ) :: key type ( indent_tracker ), pointer :: current , new_entry ! Find or create entry for this indent current => indent_history do while ( associated ( current )) if ( current % indent == indent ) then current % last_key = trim ( key ) current % line_num = line_num return endif current => current % next end do ! Create new entry allocate ( new_entry ) new_entry % indent = indent new_entry % last_key = trim ( key ) new_entry % line_num = line_num new_entry % next => indent_history indent_history => new_entry end subroutine !> Clean up indent history when done parsing subroutine cleanup_indent_history () type ( indent_tracker ), pointer :: current , next current => indent_history do while ( associated ( current )) next => current % next deallocate ( current ) current => next end do indent_history => null () end subroutine end module yaml_parser","tags":"","loc":"sourcefile/yaml_parser.f90.html"},{"title":"fyaml.F90 – Fyaml","text":"This file depends on sourcefile~~fyaml.f90~~EfferentGraph sourcefile~fyaml.f90 fyaml.F90 sourcefile~yaml_parser.f90 yaml_parser.F90 sourcefile~fyaml.f90->sourcefile~yaml_parser.f90 sourcefile~yaml_types.f90 yaml_types.F90 sourcefile~fyaml.f90->sourcefile~yaml_types.f90 sourcefile~yaml_parser.f90->sourcefile~yaml_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> A modern Fortran module for parsing YAML files !! !! This module provides functionality to read and parse YAML files into Fortran !! data structures. It supports nested dictionaries, sequences, and various data types. !! !! Example: !! ```fortran !! type(fyaml_doc) :: doc !! call doc%load(\"config.yaml\") !! value = doc%get(\"config%nested%key\") !! ``` !! !! @note Supports strings, integers, reals, booleans, nulls, and sequences !! @version 1.0.0 !! @see yaml_parser !! @see yaml_types module fyaml use yaml_parser , only : yaml_node , check_sequence_node , parse_yaml , debug_print , DEBUG_INFO ! Add DEBUG_INFO to imports use yaml_types use , intrinsic :: iso_fortran_env , only : error_unit implicit none private public :: fyaml_doc , yaml_value , yaml_dict , yaml_pair , error_unit public :: split_key , count_children , get_child_keys , get_root_keys ! Add count_children, get_child_keys, and get_root_keys to public list ! Add interface declaration for nested value getters interface get_nested_value module procedure get_value_nested module procedure get_doc_nested end interface ! Add interface declaration for safe_allocate_string interface subroutine safe_allocate_string ( str , length , status ) character ( len = :), allocatable , intent ( out ) :: str integer , intent ( in ) :: length integer , intent ( out ) :: status end subroutine safe_allocate_string end interface ! Add new interface declaration for count_children interface count_children module procedure count_node_children module procedure count_value_children end interface ! Add interface for get_child_keys interface get_child_keys module procedure get_node_child_keys module procedure get_value_child_keys end interface ! Add private declarations here private :: get_doc_nested private :: get_nested_str private :: get_nested_int private :: get_nested_real private :: get_nested_bool ! Add boolean getter private :: get_value_nested private :: find_child_by_key private :: check_sequence_impl ! New private implementation private :: safe_allocate_string private :: determine_value_type ! New private subroutine private :: get_sequence_values ! Add private declaration private :: get_sequence_integers ! Add private declaration private :: get_sequence_reals ! Add private declaration private :: get_sequence_bools ! Add private declaration private :: get_sequence_size ! Add to private declarations !> Value container type supporting multiple YAML data types !! !! Wraps a yaml_node pointer and provides type-safe access methods type :: yaml_value type ( yaml_node ), pointer :: node => null () !< Direct reference to yaml_parser node contains procedure :: get => get_value_nested !< Get value using dot notation path (rename to avoid conflict) procedure :: get_str => get_string_value !< Get string value procedure :: get_int => get_integer_value !< Get integer value procedure :: get_real => get_real_value !< Get real value procedure :: get_bool => get_boolean_value !< Get boolean value procedure :: is_null => check_null !< Check if value is null procedure :: is_sequence => check_sequence_impl !< Check if value is sequence procedure :: child_keys => get_value_child_keys ! Add method to type procedure :: child_at => get_child_at_index ! Add new method procedure :: get_sequence => get_sequence_values ! String sequence (default) procedure :: get_sequence_int => get_sequence_integers ! Integer sequence procedure :: get_sequence_real => get_sequence_reals ! Real sequence procedure :: get_sequence_bool => get_sequence_bools ! Boolean sequence procedure :: size => get_sequence_size ! Add size method end type yaml_value !> Dictionary key-value pair type !! !! Represents a single key-value entry in a YAML dictionary type :: yaml_pair character ( len = :), allocatable :: key !< Dictionary key type ( yaml_value ) :: value !< Value container type ( yaml_dict ), pointer :: nested => null () !< Nested dictionary type ( yaml_pair ), pointer :: next => null () !< Next pair in linked list integer :: indent_level = 0 !< Indentation level (0 for root) end type yaml_pair !> Dictionary container type !! !! Manages a collection of key-value pairs in a linked list structure type :: yaml_dict type ( yaml_pair ), pointer :: first => null () !< First key-value pair integer :: count = 0 !< Number of entries contains procedure :: get => get_value !< Get value by key procedure :: set => set_value !< Set value for key procedure :: keys => get_keys !< Get all keys end type yaml_dict !> Main document type for YAML parsing !! !! Represents a complete YAML document with support for multiple documents type :: fyaml_doc type ( yaml_dict ), allocatable :: docs (:) !< Array of documents integer :: n_docs = 0 !< Number of documents contains procedure :: load => load_yaml_doc !< Load YAML from file procedure :: get => get_doc_nested !< Get nested value using % delimiter procedure :: get_str => get_nested_str !< Get string value using % path procedure :: get_int => get_nested_int !< Get integer value using % path procedure :: get_real => get_nested_real !< Get real value using % path procedure :: get_bool => get_nested_bool !< Get boolean value using % path procedure :: get_doc => get_document !< Get specific document procedure :: get_default_doc => get_default_doc !< Get value from default document (first document) procedure :: root_keys => get_root_keys !< Get all root level keys end type fyaml_doc contains !> Load YAML document from file !! !! @param[in,out] this     The document instance !! @param[in]     filename Path to YAML file !! @param[out]    success  Optional success indicator subroutine load_yaml_doc ( this , filename , success ) class ( fyaml_doc ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: filename logical , intent ( out ), optional :: success type ( yaml_document ), allocatable :: parsed_docs (:) logical :: ok , file_exists integer :: rc , ios , i integer :: unit_num character ( len = 1024 ) :: buffer ok = . false . ! Clean up any existing documents if ( allocated ( this % docs )) deallocate ( this % docs ) this % n_docs = 0 ! Check if file exists first inquire ( file = filename , exist = file_exists ) if (. not . file_exists ) then write ( error_unit , * ) 'YAML file not found:' , trim ( filename ) if ( present ( success )) success = . false . return endif ! Open file with error checking open ( newunit = unit_num , file = filename , status = 'old' , action = 'read' , iostat = ios , iomsg = buffer ) if ( ios /= 0 ) then write ( error_unit , * ) 'Error opening file:' , trim ( filename ), ' - ' , trim ( buffer ) if ( present ( success )) success = . false . return endif ! Test read first line to verify file is readable read ( unit_num , '(A)' , iostat = ios , end = 100 ) buffer if ( ios /= 0 ) then write ( error_unit , * ) 'Error reading file:' , trim ( filename ) if ( present ( success )) success = . false . close ( unit_num ) return endif rewind ( unit_num ) ! Parse YAML with error handling call parse_yaml ( filename , parsed_docs , rc ) close ( unit_num ) if ( rc /= 0 ) then write ( error_unit , * ) 'Error parsing YAML:' , trim ( filename ) if ( present ( success )) success = . false . return endif if (. not . allocated ( parsed_docs )) then write ( error_unit , * ) 'No documents parsed from file:' , trim ( filename ) if ( present ( success )) success = . false . return endif ! Store number of documents and allocate docs array this % n_docs = size ( parsed_docs ) allocate ( this % docs ( this % n_docs ), stat = ios ) if ( ios /= 0 ) then write ( error_unit , * ) 'Error allocating document array' if ( present ( success )) success = . false . if ( allocated ( parsed_docs )) deallocate ( parsed_docs ) return endif ! Convert each document with error checking do i = 1 , this % n_docs if ( associated ( parsed_docs ( i )% root )) then call convert_node_to_dict ( parsed_docs ( i )% root , this % docs ( i )) ok = . true . else write ( error_unit , * ) 'Warning: Document' , i , 'has no root node' endif end do if ( allocated ( parsed_docs )) deallocate ( parsed_docs ) if ( present ( success )) success = ok return 100 continue ! Handle empty file write ( error_unit , * ) 'Empty or invalid YAML file:' , trim ( filename ) if ( present ( success )) success = . false . close ( unit_num ) return end subroutine load_yaml_doc !> Convert a yaml_node to yaml_value !! !! @param[in] node Source YAML node !! @return Value container wrapping the node function node_to_value ( node ) result ( val ) type ( yaml_node ), pointer , intent ( in ) :: node type ( yaml_value ) :: val if (. not . associated ( node )) then val % node => null () return endif val % node => node end function !> Get string value from yaml_value !! !! @param[in] self Value container instance !! @return String value or empty string if invalid function get_string_value ( self ) result ( str_val ) class ( yaml_value ), intent ( inout ) :: self ! Changed from intent(in) to intent(inout) character ( len = :), allocatable :: str_val logical :: was_string if (. not . associated ( self % node )) then str_val = '' write ( error_unit , * ) \"DEBUG: Node not associated for string value\" return endif ! Store if it was already marked as string was_string = self % node % is_string ! Force type determination if not already done call determine_value_type ( self % node ) ! If it wasn't originally a string but became one, or was one already if ( self % node % is_string . or . was_string ) then str_val = trim ( self % node % value ) write ( error_unit , * ) \"DEBUG: Retrieved string value:\" , trim ( str_val ) else str_val = '' write ( error_unit , * ) \"DEBUG: Node is not a string type. Type flags:\" , & \" is_string=\" , self % node % is_string , & \" is_integer=\" , self % node % is_integer , & \" is_float=\" , self % node % is_float , & \" is_boolean=\" , self % node % is_boolean endif end function !> Get integer value from yaml_value !! !! @param[in] self Value container instance !! @return Integer value or 0 if invalid function get_integer_value ( self ) result ( int_val ) class ( yaml_value ), intent ( inout ) :: self ! Changed from intent(in) to intent(inout) integer :: int_val integer :: ios int_val = 0 if (. not . associated ( self % node )) then write ( error_unit , * ) \"DEBUG: Node not associated for integer value\" return endif ! Force type determination if not already done if (. not . self % node % is_integer ) then call determine_value_type ( self % node ) endif if ( self % node % is_integer ) then read ( self % node % value , * , iostat = ios ) int_val if ( ios /= 0 ) then write ( error_unit , * ) \"DEBUG: Failed to convert value to integer:\" , trim ( self % node % value ) int_val = 0 else write ( error_unit , * ) \"DEBUG: Successfully converted to integer:\" , int_val endif else write ( error_unit , * ) \"DEBUG: Node is not an integer type. Value:\" , trim ( self % node % value ) endif end function !> Get real value from yaml_value !! !! @param[in] self Value container instance !! @return Real value or 0.0 if invalid function get_real_value ( self ) result ( real_val ) class ( yaml_value ), intent ( inout ) :: self real :: real_val real_val = 0.0 if ( associated ( self % node ) . and . self % node % is_float ) then read ( self % node % value , * ) real_val endif end function !> Get boolean value from yaml_value !! !! @param[in] self Value container instance !! @return Boolean value or false if invalid function get_boolean_value ( self ) result ( bool_val ) class ( yaml_value ), intent ( inout ) :: self logical :: bool_val bool_val = . false . if ( associated ( self % node ) . and . self % node % is_boolean ) then bool_val = ( trim ( self % node % value ) == 'true' ) endif end function !> Check if value is null !! !! @param[in] self Value container instance !! @return True if value is null function check_null ( self ) result ( is_null ) class ( yaml_value ), intent ( in ) :: self logical :: is_null is_null = . not . associated ( self % node ) . or . self % node % is_null end function !> Check if value is a sequence !! !! @param[in] self Value container instance !! @return True if value is a sequence function check_sequence_impl ( self ) result ( is_seq ) class ( yaml_value ), intent ( in ) :: self logical :: is_seq is_seq = . false . if ( associated ( self % node )) then is_seq = check_sequence_node ( self % node ) endif end function check_sequence_impl !> Print yaml_node children keys !! !! @param[in] node Node to print !! @param[in] prefix Optional indentation prefix subroutine print_node_children ( node , prefix ) type ( yaml_node ), pointer , intent ( in ) :: node character ( len =* ), intent ( in ), optional :: prefix type ( yaml_node ), pointer :: current character ( len = :), allocatable :: indent if (. not . associated ( node )) then write ( error_unit , * ) \"No node to print children\" return endif indent = \"\" if ( present ( prefix )) indent = prefix write ( error_unit , * ) trim ( indent ) // \"Node key:\" , trim ( node % key ) write ( error_unit , * ) trim ( indent ) // \"Node value:\" , trim ( node % value ) write ( error_unit , * ) trim ( indent ) // \"Has children:\" , associated ( node % children ) if ( associated ( node % children )) then write ( error_unit , * ) trim ( indent ) // \"Children:\" current => node % children do while ( associated ( current )) write ( error_unit , * ) trim ( indent ) // \"  -\" , trim ( current % key ), & \" (value:\" , trim ( current % value ), \")\" , & \" has_children:\" , associated ( current % children ) current => current % next end do endif end subroutine print_node_children !> Convert YAML node structure to dictionary !! !! @param[in] node Source node to convert !! @param[inout] dict Target dictionary recursive subroutine convert_node_to_dict ( node , dict ) type ( yaml_node ), pointer , intent ( in ) :: node type ( yaml_dict ), intent ( inout ) :: dict type ( yaml_pair ), pointer :: new_pair , last_pair , root_pair , current_node type ( yaml_node ), pointer :: current character ( len = 256 ) :: debug_msg logical :: is_root_level integer :: alloc_stat if (. not . associated ( node )) then write ( error_unit , * ) \"WARNING: Empty node passed to convert_node_to_dict\" return endif current => node nullify ( last_pair ) nullify ( root_pair ) do while ( associated ( current )) ! Check if this is a root-level node (no parent) is_root_level = (. not . associated ( current % parent )) if ( is_root_level ) then current % is_root = . true . ! Changed from is_root_key to is_root endif ! Fix the format specifier to match the arguments write ( debug_msg , '(A,A,A,I0,A,L1,A,I0)' ) \"Converting node: \" , & trim ( current % value ), & \" at line \" , current % line_num , & \" root: \" , is_root_level , & \" indent: \" , current % indent call debug_print ( DEBUG_INFO , debug_msg ) ! Create new pair allocate ( new_pair , stat = alloc_stat ) if ( alloc_stat /= 0 ) then write ( error_unit , * ) \"ERROR: Failed to allocate new pair\" return endif ! Initialize new pair new_pair % key = trim ( adjustl ( current % key )) nullify ( new_pair % next ) new_pair % value % node => current new_pair % indent_level = current % indent ! Changed from indent_level to indent ! Handle nested structures if ( associated ( current % children )) then write ( debug_msg , '(A,A,A,L1,A,I0)' ) \"Creating nested dictionary for: \" , & trim ( current % key ), & \" (root level: \" , is_root_level , & \" indent: \" , current % indent ! Changed from indent_level to indent call debug_print ( DEBUG_INFO , debug_msg ) ! Create nested dictionary allocate ( new_pair % nested , stat = alloc_stat ) if ( alloc_stat /= 0 ) then write ( error_unit , * ) \"ERROR: Failed to allocate nested dictionary\" deallocate ( new_pair ) return endif ! Initialize nested dictionary new_pair % nested % first => null () new_pair % nested % count = 0 ! Convert children call convert_node_to_dict ( current % children , new_pair % nested ) endif ! Link into dictionary based on root level status if ( is_root_level ) then ! For root-level nodes, start new chain if (. not . associated ( dict % first )) then dict % first => new_pair root_pair => new_pair else ! Link at root level if ( associated ( root_pair )) then root_pair % next => new_pair root_pair => new_pair else ! Find end of root chain root_pair => dict % first do while ( associated ( root_pair % next )) root_pair => root_pair % next end do root_pair % next => new_pair root_pair => new_pair endif endif write ( debug_msg , '(A,A)' ) \"Added root level node: \" , trim ( new_pair % key ) call debug_print ( DEBUG_INFO , debug_msg ) else ! For non-root nodes, maintain existing hierarchy if (. not . associated ( last_pair )) then ! Find correct parent based on hierarchy if ( associated ( current % parent )) then ! Follow parent's hierarchy last_pair => dict % first do while ( associated ( last_pair )) if ( associated ( last_pair % value % node , current % parent )) then if (. not . associated ( last_pair % nested )) then allocate ( last_pair % nested ) last_pair % nested % first => new_pair else ! Find end of nested chain current_node => last_pair % nested % first if ( associated ( current_node )) then do while ( associated ( current_node % next )) current_node => current_node % next end do current_node % next => new_pair else last_pair % nested % first => new_pair endif endif exit endif last_pair => last_pair % next end do endif else last_pair % next => new_pair endif endif ! Update tracking for next iteration if (. not . is_root_level ) then last_pair => new_pair endif dict % count = dict % count + 1 ! Move to next node current => current % next end do end subroutine convert_node_to_dict !> Set value for a given key in dictionary !! !! @param[in,out] this  The dictionary instance !! @param[in]     key   Key to set !! @param[in]     value Value to associate with key subroutine set_value ( this , key , value ) class ( yaml_dict ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: key type ( yaml_value ), intent ( in ) :: value type ( yaml_pair ), pointer :: current , new_pair ! Check if key exists current => this % first do while ( associated ( current )) if ( current % key == key ) then ! Update existing value current % value = value return endif current => current % next end do ! Key doesn't exist, create new pair allocate ( new_pair ) new_pair % key = key new_pair % value = value ! Add to beginning of list new_pair % next => this % first this % first => new_pair this % count = this % count + 1 end subroutine set_value !> Get value associated with key from dictionary !! !! @param[in] this Dictionary instance !! @param[in] key Key to lookup !! @return Value associated with key function get_value ( this , key ) result ( val ) class ( yaml_dict ), intent ( inout ) :: this ! Changed from intent(in) to intent(inout) character ( len =* ), intent ( in ) :: key type ( yaml_value ) :: val type ( yaml_pair ), pointer :: current character ( len = :), allocatable , dimension (:) :: key_parts character ( len = :), allocatable :: remaining_path integer :: i , path_start write ( error_unit , * ) \"DEBUG: Dictionary get_value for key:\" , trim ( key ) val % node => null () ! Split key into parts key_parts = split_key ( key ) write ( error_unit , * ) \"DEBUG: Looking for key part:\" , trim ( key_parts ( 1 )) ! Start with first level search current => this % first do while ( associated ( current )) write ( error_unit , * ) \"DEBUG: Checking pair with key:\" , trim ( current % key ), & \" against target:\" , trim ( key_parts ( 1 )) ! Do exact string comparison after trimming and adjusting if ( trim ( adjustl ( current % key )) == trim ( adjustl ( key_parts ( 1 )))) then write ( error_unit , * ) \"DEBUG: Found first level match for:\" , trim ( key_parts ( 1 )) if ( size ( key_parts ) == 1 ) then ! Direct match at this level val % node => current % value % node ! Ensure type is determined for direct matches call determine_value_type ( val % node ) write ( error_unit , * ) \"DEBUG: Found direct match at first level\" write ( error_unit , * ) \"DEBUG: Node has children:\" , associated ( val % node % children ) write ( error_unit , * ) \"DEBUG: Node value:\" , trim ( val % node % value ) write ( error_unit , * ) \"DEBUG: Is integer:\" , val % node % is_integer return else ! For nested access val % node => current % value % node write ( error_unit , * ) \"DEBUG: Node children status:\" , associated ( val % node % children ) if (. not . associated ( val % node % children )) then write ( error_unit , * ) \"DEBUG: No children available for nested access\" val % node => null () else ! Get remaining path path_start = len_trim ( key_parts ( 1 )) + 2 remaining_path = trim ( key ( path_start :)) write ( error_unit , * ) \"DEBUG: Continuing with nested path:\" , trim ( remaining_path ) val = val % get ( remaining_path ) endif return endif endif write ( error_unit , * ) \"DEBUG: Moving to next pair\" current => current % next end do write ( error_unit , * ) \"DEBUG: Key not found in dictionary:\" , trim ( key_parts ( 1 )) val % node => null () end function get_value !> Get all keys in dictionary !! !! @param[in]  this Dictionary instance !! @return     Array of all keys function get_keys ( this ) result ( keys ) class ( yaml_dict ), intent ( in ) :: this character ( len = :), allocatable , dimension (:) :: keys type ( yaml_pair ), pointer :: current integer :: i if ( this % count > 0 ) then allocate ( character ( len = 32 ) :: keys ( this % count )) keys = \"\" current => this % first i = 1 do while ( associated ( current )) keys ( i ) = current % key i = i + 1 current => current % next end do else allocate ( character ( len = 0 ) :: keys ( 0 )) endif end function get_keys !> Get nested value for yaml_value type !! !! @param[in] self Value container instance !! @param[in] key Nested key path with % delimiters !! @return Value at nested path recursive function get_value_nested ( self , key ) result ( val ) class ( yaml_value ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: key type ( yaml_value ) :: val , temp_val character ( len = :), allocatable , dimension (:) :: key_parts character ( len = :), allocatable :: remaining_path type ( yaml_node ), pointer :: current integer :: i write ( error_unit , * ) \"DEBUG: Starting get_value_nested for key:\" , trim ( key ) val % node => null () if (. not . associated ( self % node )) then write ( error_unit , * ) \"DEBUG: Initial node is not associated\" return endif ! Split key into parts key_parts = split_key ( key ) write ( error_unit , * ) \"DEBUG: Looking for first key part:\" , trim ( key_parts ( 1 )) ! Handle direct children mode for better traversal current => self % node if ( associated ( current % children )) then current => current % children else write ( error_unit , * ) \"DEBUG: Node has no children\" return endif ! Search through children at this level do while ( associated ( current )) write ( error_unit , * ) \"DEBUG: Checking node key:\" , trim ( current % key ), & \" against target:\" , trim ( key_parts ( 1 )) if ( trim ( adjustl ( current % key )) == trim ( adjustl ( key_parts ( 1 )))) then write ( error_unit , * ) \"DEBUG: Found match for:\" , trim ( key_parts ( 1 )) if ( size ( key_parts ) == 1 ) then ! Found final target val % node => current call determine_value_type ( val % node ) write ( error_unit , * ) \"DEBUG: Final target found with value:\" , trim ( val % node % value ) return else ! Need to traverse deeper temp_val % node => current write ( error_unit , * ) \"DEBUG: Going deeper with node:\" , trim ( current % key ) ! Build remaining path remaining_path = \"\" do i = 2 , size ( key_parts ) if ( i > 2 ) remaining_path = trim ( remaining_path ) // \"%\" remaining_path = trim ( remaining_path ) // trim ( key_parts ( i )) end do write ( error_unit , * ) \"DEBUG: Continuing with remaining path:\" , trim ( remaining_path ) val = temp_val % get ( remaining_path ) return endif endif current => current % next end do write ( error_unit , * ) \"DEBUG: Key not found:\" , trim ( key_parts ( 1 )) end function get_value_nested !> Get nested value for fyaml_doc type !! !! @param[in] self Document instance !! @param[in] path Nested path with % delimiters !! @param[in] doc_index Optional document index !! @return Value at nested path recursive function get_doc_nested ( self , path , doc_index ) result ( val ) class ( fyaml_doc ), intent ( inout ) :: self ! Changed from intent(in) to intent(inout) character ( len =* ), intent ( in ) :: path integer , intent ( in ), optional :: doc_index type ( yaml_value ) :: val integer :: doc_idx doc_idx = 1 ! Default to first document if ( present ( doc_index )) doc_idx = doc_index if ( doc_idx < 1 . or . doc_idx > self % n_docs ) then val % node => null () return endif val = self % docs ( doc_idx )% get ( path ) end function get_doc_nested !> Get nested string value !! !! @param[in] self Document instance !! @param[in] path Nested path with % delimiters !! @param[in] doc_index Optional document index !! @return String value at nested path function get_nested_str ( self , path , doc_index ) result ( val ) class ( fyaml_doc ), intent ( inout ) :: self ! Changed from intent(in) to intent(inout) character ( len =* ), intent ( in ) :: path integer , intent ( in ), optional :: doc_index character ( len = :), allocatable :: val type ( yaml_value ) :: temp write ( error_unit , * ) \"DEBUG: Getting nested string for path:\" , trim ( path ) temp = self % get ( path , doc_index ) if ( associated ( temp % node )) then ! Force type determination call determine_value_type ( temp % node ) ! Mark as string if not already typed if (. not . ( temp % node % is_integer . or . temp % node % is_float . or . & temp % node % is_boolean . or . temp % node % is_null )) then temp % node % is_string = . true . endif write ( error_unit , * ) \"DEBUG: Found node value:\" , trim ( temp % node % value ) write ( error_unit , * ) \"DEBUG: Node type flags - string:\" , temp % node % is_string , & \" int:\" , temp % node % is_integer , & \" float:\" , temp % node % is_float , & \" bool:\" , temp % node % is_boolean ! Get string value val = trim ( temp % node % value ) write ( error_unit , * ) \"DEBUG: Returning string value:\" , trim ( val ) else write ( error_unit , * ) \"DEBUG: Node not found for path:\" , trim ( path ) val = '' endif end function get_nested_str !> Get nested integer value !! !! @param[in] self Document instance !! @param[in] path Nested path with % delimiters !! @param[in] doc_index Optional document index !! @return Integer value at nested path function get_nested_int ( self , path , doc_index ) result ( val ) class ( fyaml_doc ), intent ( inout ) :: self ! Changed from intent(in) to intent(inout) character ( len =* ), intent ( in ) :: path integer , intent ( in ), optional :: doc_index integer :: val type ( yaml_value ) :: temp write ( error_unit , * ) \"DEBUG: Getting nested integer for path:\" , trim ( path ) temp = self % get ( path , doc_index ) if ( associated ( temp % node )) then ! Force type determination call determine_value_type ( temp % node ) val = temp % get_int () write ( error_unit , * ) \"DEBUG: Found integer value:\" , val else write ( error_unit , * ) \"DEBUG: Node not found, returning 0\" val = 0 endif end function get_nested_int !> Get nested real value !! !! @param[in] self Document instance !! @param[in] path Nested path with % delimiters !! @param[in] doc_index Optional document index !! @return Real value at nested path function get_nested_real ( self , path , doc_index ) result ( val ) class ( fyaml_doc ), intent ( inout ) :: self ! Changed from intent(in) to intent(inout) character ( len =* ), intent ( in ) :: path integer , intent ( in ), optional :: doc_index real :: val type ( yaml_value ) :: temp temp = self % get ( path , doc_index ) if ( associated ( temp % node )) then val = temp % get_real () else val = 0.0 endif end function get_nested_real !> Get nested boolean value !! !! @param[in] self Document instance !! @param[in] path Nested path with % delimiters !! @param[in] doc_index Optional document index !! @return Boolean value at nested path function get_nested_bool ( self , path , doc_index ) result ( val ) class ( fyaml_doc ), intent ( inout ) :: self ! Changed from intent(in) to intent(inout) character ( len =* ), intent ( in ) :: path integer , intent ( in ), optional :: doc_index logical :: val type ( yaml_value ) :: temp temp = self % get ( path , doc_index ) if ( associated ( temp % node )) then val = temp % get_bool () else val = . false . endif end function get_nested_bool !> Get specific document by index !! !! @param[in] this Document collection !! @param[in] doc_index Index of document to get !! @return Document at specified index function get_document ( this , doc_index ) result ( val ) class ( fyaml_doc ), intent ( in ) :: this integer , intent ( in ) :: doc_index type ( yaml_dict ) :: val ! Changed from pointer to regular type if ( doc_index > 0 . and . doc_index <= this % n_docs ) then val = this % docs ( doc_index ) ! Regular assignment instead of pointer assignment endif end function get_document !> Get value from default document (first document) !! !! @param[in] this Document collection !! @return First document in collection function get_default_doc ( this ) result ( val ) class ( fyaml_doc ), intent ( in ) :: this type ( yaml_dict ) :: val if ( this % n_docs > 0 ) then val = this % docs ( 1 ) endif end function get_default_doc !> Find child node by key !! !! @param[in] node Parent node to search !! @param[in] search_key Key to find !! @return Value container for found child function find_child_by_key ( node , search_key ) result ( found_val ) type ( yaml_node ), pointer , intent ( in ) :: node character ( len =* ), intent ( in ) :: search_key type ( yaml_value ) :: found_val type ( yaml_node ), pointer :: current write ( error_unit , * ) \"DEBUG: Searching for child with key:\" , trim ( search_key ) found_val % node => null () ! Search only immediate children if ( associated ( node % children )) then current => node % children do while ( associated ( current )) write ( error_unit , * ) \"DEBUG: Checking child node:\" , trim ( current % key ) if ( trim ( adjustl ( current % key )) == trim ( adjustl ( search_key ))) then write ( error_unit , * ) \"DEBUG: Found matching child node\" found_val % node => current ! Preserve sequence flags if ( current % is_sequence . and . associated ( current % children )) then current % children % is_sequence = . true . endif return endif current => current % next end do endif write ( error_unit , * ) \"DEBUG: Child not found\" end function find_child_by_key !> Split a path by % delimiter !! !! @param[in] path Path string to split !! @return Array of path segments function split_key ( path ) result ( parts ) character ( len =* ), intent ( in ) :: path character ( len = :), allocatable , dimension (:) :: parts integer :: n_parts , i , prev_pos , pos ! Count parts n_parts = 1 do i = 1 , len_trim ( path ) if ( path ( i : i ) == '%' ) n_parts = n_parts + 1 end do ! Allocate parts array allocate ( character ( len = 32 ) :: parts ( n_parts )) ! Split string prev_pos = 1 i = 1 do pos = index ( path ( prev_pos :), '%' ) if ( pos == 0 ) then parts ( i ) = trim ( adjustl ( path ( prev_pos :))) exit endif parts ( i ) = trim ( adjustl ( path ( prev_pos : prev_pos + pos - 2 ))) prev_pos = prev_pos + pos i = i + 1 end do ! Clean up each part do i = 1 , n_parts parts ( i ) = trim ( adjustl ( parts ( i ))) end do end function split_key !> Determine the type of a node's value !! !! @param[inout] node Node to analyze subroutine determine_value_type ( node ) type ( yaml_node ), pointer , intent ( inout ) :: node integer :: int_val , ios real :: real_val character ( len = :), allocatable :: cleaned_value ! Reset type flags if (. not . associated ( node )) then write ( error_unit , * ) \"DEBUG: Cannot determine type for null node\" return endif node % is_integer = . false . node % is_float = . false . node % is_boolean = . false . node % is_string = . false . node % is_null = . false . ! Clean the value cleaned_value = trim ( adjustl ( node % value )) if ( len_trim ( cleaned_value ) == 0 . or . cleaned_value == '~' ) then node % is_null = . true . write ( error_unit , * ) \"DEBUG: Value determined as null\" return endif ! Try integer first read ( cleaned_value , * , iostat = ios ) int_val if ( ios == 0 . and . index ( cleaned_value , '.' ) == 0 . and . & index ( cleaned_value , 'e' ) == 0 . and . index ( cleaned_value , 'E' ) == 0 ) then node % is_integer = . true . write ( error_unit , * ) \"DEBUG: Value determined as integer:\" , int_val return endif ! Try real read ( cleaned_value , * , iostat = ios ) real_val if ( ios == 0 ) then node % is_float = . true . write ( error_unit , * ) \"DEBUG: Value determined as real:\" , real_val return endif ! Check boolean if ( cleaned_value == 'true' . or . cleaned_value == 'false' ) then node % is_boolean = . true . write ( error_unit , * ) \"DEBUG: Value determined as boolean:\" , trim ( cleaned_value ) return endif ! Default to string node % is_string = . true . write ( error_unit , * ) \"DEBUG: Value determined as string:\" , trim ( cleaned_value ) end subroutine determine_value_type !> Count direct children of a yaml_node !! !! @param[in] node Node to count children for !! @return Number of direct children function count_node_children ( node ) result ( count ) type ( yaml_node ), pointer , intent ( in ) :: node integer :: count type ( yaml_node ), pointer :: current count = 0 if (. not . associated ( node )) return if (. not . associated ( node % children )) return current => node % children do while ( associated ( current )) count = count + 1 current => current % next end do end function count_node_children !> Count direct children of a yaml_value !! !! @param[in] val Value to count children for !! @return Number of direct children function count_value_children ( val ) result ( count ) type ( yaml_value ), intent ( in ) :: val integer :: count if (. not . associated ( val % node )) then count = 0 return endif count = count_node_children ( val % node ) end function count_value_children !> Get all child keys of a yaml_node !! !! @param[in] node Node to get children from !! @return Array of child key names function get_node_child_keys ( node ) result ( keys ) type ( yaml_node ), pointer , intent ( in ) :: node character ( len = :), allocatable , dimension (:) :: keys type ( yaml_node ), pointer :: current integer :: count , i ! Initialize with empty array allocate ( character ( len = 0 ) :: keys ( 0 )) ! Early return checks if (. not . associated ( node )) return if (. not . associated ( node % children )) return ! Count children first count = count_node_children ( node ) ! Allocate array for keys if ( allocated ( keys )) deallocate ( keys ) allocate ( character ( len = 32 ) :: keys ( count )) ! Fill array with child keys current => node % children i = 1 do while ( associated ( current )) keys ( i ) = trim ( adjustl ( current % key )) i = i + 1 current => current % next end do end function get_node_child_keys !> Get all child keys of a yaml_value !! !! @param[in] val Value to get children from !! @return Array of child key names function get_value_child_keys ( val ) result ( keys ) class ( yaml_value ), intent ( in ) :: val character ( len = :), allocatable , dimension (:) :: keys if (. not . associated ( val % node )) then allocate ( character ( len = 0 ) :: keys ( 0 )) return endif keys = get_node_child_keys ( val % node ) end function get_value_child_keys !> Get child value at specified index !! !! @param[in] self Value container instance !! @param[in] idx Index of child to retrieve (1-based) !! @return Value container for child at index or null if invalid function get_child_at_index ( self , idx ) result ( val ) class ( yaml_value ), intent ( in ) :: self integer , intent ( in ) :: idx type ( yaml_value ) :: val type ( yaml_node ), pointer :: current integer :: current_idx ! Initialize result val % node => null () ! Check for valid node and children if (. not . associated ( self % node )) return if (. not . associated ( self % node % children )) return if ( idx < 1 ) return ! Traverse to desired index current => self % node % children current_idx = 1 do while ( associated ( current )) if ( current_idx == idx ) then val % node => current return endif current => current % next current_idx = current_idx + 1 end do end function get_child_at_index !> Get sequence values as an array of strings !! !! @param[in] self Value container instance !! @return Array of sequence values as strings function get_sequence_values ( self ) result ( values ) class ( yaml_value ), intent ( in ) :: self character ( len = :), allocatable , dimension (:) :: values type ( yaml_node ), pointer :: current integer :: count , i ! Initialize with empty array allocate ( character ( len = 0 ) :: values ( 0 )) ! Early return checks if (. not . associated ( self % node )) return if (. not . associated ( self % node % children )) return if (. not . self % is_sequence ()) return ! Count items first count = count_node_children ( self % node ) if ( count == 0 ) return ! Allocate array for values if ( allocated ( values )) deallocate ( values ) allocate ( character ( len = 32 ) :: values ( count )) ! Fill array with values current => self % node % children i = 1 do while ( associated ( current )) values ( i ) = trim ( adjustl ( current % value )) i = i + 1 current => current % next end do end function get_sequence_values !> Get sequence values as integers !! !! @param[in] self Value container instance !! @return Array of sequence values as integers function get_sequence_integers ( self ) result ( values ) class ( yaml_value ), intent ( in ) :: self integer , allocatable , dimension (:) :: values type ( yaml_node ), pointer :: current integer :: count , i , ios ! Initialize with empty array allocate ( values ( 0 )) ! Early return checks if (. not . associated ( self % node )) return if (. not . associated ( self % node % children )) return if (. not . self % is_sequence ()) return ! Count and allocate count = count_node_children ( self % node ) if ( count == 0 ) return if ( allocated ( values )) deallocate ( values ) allocate ( values ( count )) values = 0 ! Initialize to default value ! Fill array with integer values current => self % node % children i = 1 do while ( associated ( current )) read ( current % value , * , iostat = ios ) values ( i ) if ( ios /= 0 ) values ( i ) = 0 ! Set to 0 if conversion fails i = i + 1 current => current % next end do end function get_sequence_integers !> Get sequence values as reals !! !! @param[in] self Value container instance !! @return Array of sequence values as reals function get_sequence_reals ( self ) result ( values ) class ( yaml_value ), intent ( in ) :: self real , allocatable , dimension (:) :: values type ( yaml_node ), pointer :: current integer :: count , i , ios ! Initialize with empty array allocate ( values ( 0 )) ! Early return checks if (. not . associated ( self % node )) return if (. not . associated ( self % node % children )) return if (. not . self % is_sequence ()) return ! Count and allocate count = count_node_children ( self % node ) if ( count == 0 ) return if ( allocated ( values )) deallocate ( values ) allocate ( values ( count )) values = 0.0 ! Initialize to default value ! Fill array with real values current => self % node % children i = 1 do while ( associated ( current )) read ( current % value , * , iostat = ios ) values ( i ) if ( ios /= 0 ) values ( i ) = 0.0 ! Set to 0.0 if conversion fails i = i + 1 current => current % next end do end function get_sequence_reals !> Get sequence values as logicals !! !! @param[in] self Value container instance !! @return Array of sequence values as logicals function get_sequence_bools ( self ) result ( values ) class ( yaml_value ), intent ( in ) :: self logical , allocatable , dimension (:) :: values type ( yaml_node ), pointer :: current integer :: count , i ! Initialize with empty array allocate ( values ( 0 )) ! Early return checks if (. not . associated ( self % node )) return if (. not . associated ( self % node % children )) return if (. not . self % is_sequence ()) return ! Count and allocate count = count_node_children ( self % node ) if ( count == 0 ) return if ( allocated ( values )) deallocate ( values ) allocate ( values ( count )) values = . false . ! Initialize to default value ! Fill array with boolean values current => self % node % children i = 1 do while ( associated ( current )) values ( i ) = ( trim ( adjustl ( current % value )) == 'true' ) i = i + 1 current => current % next end do end function get_sequence_bools !> Get the size of a sequence !! !! @param[in] self Value container instance !! @return Size of sequence or 0 if not a sequence/invalid function get_sequence_size ( self ) result ( size ) class ( yaml_value ), intent ( in ) :: self integer :: size size = 0 if (. not . associated ( self % node )) return if (. not . self % is_sequence ()) return size = count_node_children ( self % node ) end function get_sequence_size !> Get all root keys from the document !! !! @param[in] this Document instance !! @return Array of root key names function get_root_keys ( this ) result ( keys ) class ( fyaml_doc ), intent ( in ) :: this character ( len = :), allocatable , dimension (:) :: keys type ( yaml_pair ), pointer :: current integer :: count , i ! Count root level pairs count = 0 current => this % docs ( 1 )% first do while ( associated ( current )) if ( associated ( current % value % node ) . and . current % value % node % is_root ) then ! Changed from is_root_key count = count + 1 endif current => current % next end do ! Allocate array for keys if ( count > 0 ) then allocate ( character ( len = 32 ) :: keys ( count )) keys = \"\" ! Fill array with root keys current => this % docs ( 1 )% first i = 1 do while ( associated ( current )) if ( associated ( current % value % node ) . and . current % value % node % is_root ) then ! Changed from is_root_key keys ( i ) = current % key i = i + 1 endif current => current % next end do else allocate ( character ( len = 0 ) :: keys ( 0 )) endif end function get_root_keys end module fyaml","tags":"","loc":"sourcefile/fyaml.f90.html"},{"title":"yaml_types.F90 – Fyaml","text":"Files dependent on this one sourcefile~~yaml_types.f90~~AfferentGraph sourcefile~yaml_types.f90 yaml_types.F90 sourcefile~fyaml.f90 fyaml.F90 sourcefile~fyaml.f90->sourcefile~yaml_types.f90 sourcefile~yaml_parser.f90 yaml_parser.F90 sourcefile~fyaml.f90->sourcefile~yaml_parser.f90 sourcefile~yaml_parser.f90->sourcefile~yaml_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Core YAML type definitions !! !! Defines the fundamental types needed for YAML parsing. !! These types form the backbone of the document structure. !! !! @private module yaml_types implicit none private public :: yaml_node , yaml_document !> Core node type for YAML elements type :: yaml_node character ( len = :), allocatable :: key !< Node key name character ( len = :), allocatable :: value !< Node value content type ( yaml_node ), pointer :: children => null () !< Child nodes type ( yaml_node ), pointer :: next => null () !< Next sibling type ( yaml_node ), pointer :: parent => null () !< Parent node integer :: indent = 0 !< Indentation level integer :: line_num = 0 !< Line number in source file where node appeared integer :: last_child_line = 0 !< Line number of last processed child logical :: is_sequence = . false . !< Sequence flag logical :: is_null = . false . !< Null value flag logical :: is_boolean = . false . !< Boolean flag logical :: is_integer = . false . !< Integer flag logical :: is_float = . false . !< Float flag logical :: is_string = . true . !< String flag (default) logical :: is_root = . false . !< Root node flag (replaces is_root_key) end type yaml_node !> Document container type type :: yaml_document type ( yaml_node ), pointer :: root => null () !< Root node end type yaml_document ! Remove yaml_error type - handle errors through status codes end module yaml_types","tags":"","loc":"sourcefile/yaml_types.f90.html"},{"title":"Fyaml – Fyaml","text":"Fyaml: Modern YAML Parser for Fortran Overview Fyaml provides a robust, easy-to-use YAML parser for Fortran applications. It handles complex YAML structures while maintaining type safety and memory efficiency. Getting Started Installation git clone https://github.com/yourusername/fyaml.git cd fyaml\nmkdir build && cd build\ncmake ..\nmake install Basic Usage Read a Yaml Configuration file: # config.yaml server : host : localhost ports : - 8080 - 8081 settings : timeout : 30 debug : true Parse it in your Fortran code: program example use fyaml type ( fyaml_doc ) :: doc type ( yaml_value ) :: val integer , allocatable :: ports (:) ! Load configuration call doc % load ( \"config.yaml\" ) ! Access string values val = doc % root % get ( \"server.host\" ) print * , \"Host:\" , val % str_val ! Access arrays val = doc % root % get ( \"server.ports\" ) ports = val % int_array print * , \"Ports:\" , ports ! Access nested values val = doc % root % get ( \"server.settings.timeout\" ) print * , \"Timeout:\" , val % int_val end program Core Features Type Safety: Native Fortran type handling Memory Management: Automatic cleanup of resources Flexible Access: Dot notation for nested structures Rich Data Types: Support for: Strings Integers Real numbers Booleans Arrays Nested structures Null values API Documentation Core Modules yaml_types - Core type definitions and data structures yaml_parser - YAML parsing implementation fyaml - High-level interface Key Types ! Document container type :: fyaml_doc type ( yaml_dict ) :: root contains procedure :: load end type ! Value container type :: yaml_value integer :: value_type character ( len = :), allocatable :: str_val integer :: int_val real :: real_val logical :: bool_val type ( yaml_dict ), pointer :: dict_val => null () end type Advanced Usage Error Handling program error_handling use fyaml type ( fyaml_doc ) :: doc integer :: status call doc % load ( \"config.yaml\" , status ) if ( status /= 0 ) then print * , \"Failed to load configuration\" stop 1 endif end program Working with Arrays ! Read sequence of values val = doc % get ( \"database.ports\" ) if ( val % is_sequence ()) then ports = val % int_array endif Get all keys from a node program example use fyaml type ( fyaml_doc ) :: doc type ( yaml_value ) :: root_value character ( len = :), allocatable , dimension (:) :: keys logical :: success call doc % load ( \"example.yaml\" , success ) if (. not . success ) then write ( error_unit , * ) 'Error: Failed to load YAML file' error stop end if root_value = doc % root keys = root_value % dict_val % keys () print * , \"Root keys:\" , keys end program Debug Output with Configurable Levels use yaml_parser , only : set_debug_level , DEBUG_VERBOSE call set_debug_level ( DEBUG_VERBOSE ) Examples See our examples directory for: Basic configuration reading Complex data structures Error handling Type conversion Array handling Contributing We welcome contributions! See our contribution guidelines. License Licensed under GNU General Public License v3.0","tags":"","loc":"page/index.html"}]}